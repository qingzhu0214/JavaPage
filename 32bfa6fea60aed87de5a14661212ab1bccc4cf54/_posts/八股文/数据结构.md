如何实现稳定的快速[排序](https://www.nowcoder.com/jump/super-jump/word?word=%E6%8E%92%E5%BA%8F)  
对一个省上百万考生的考试成绩[排序](https://www.nowcoder.com/jump/super-jump/word?word=%E6%8E%92%E5%BA%8F) 要求o(n)  
交叉[链表](https://www.nowcoder.com/jump/super-jump/word?word=%E9%93%BE%E8%A1%A8)找交叉节点
如果要实现LRU[算法](https://www.nowcoder.com/jump/super-jump/word?word=%E7%AE%97%E6%B3%95)，应该选择哪种数据结构？LRU[算法](https://www.nowcoder.com/jump/super-jump/word?word=%E7%AE%97%E6%B3%95)要淘汰页面，就需要断链操作，而[链表](https://www.nowcoder.com/jump/super-jump/word?word=%E9%93%BE%E8%A1%A8)只能顺序查找，时间复杂度是O(n)，怎么能更快实现淘汰
1.  常见数据结构有什么？
2. 最小栈怎么实现
3. -   有哪些数据结构
4. -   [链表](https://www.nowcoder.com/jump/super-jump/word?word=%E9%93%BE%E8%A1%A8)和数组的区别
5. -   跳表的原理和插入过程
6. 有很多数据，各自具有依赖关系，采用什么数据结构存储

红黑树，和二叉查找树有什么区别
详细介绍一下b树跟b+树，b+数查询时间复杂度，为什么?
10w个数在硬盘，你怎么[排序](https://www.nowcoder.com/jump/super-jump/word?word=%E6%8E%92%E5%BA%8F)

### Morris遍历
[参考](https://blog.csdn.net/heshiliqiu/article/details/111540928)
假设当前正在遍历的节点是cur，那么cur的移动规则如下：
- 如果cur没有左孩子，则cur向右移动，即cur = cur.right。
- 如果cur有左孩子，找到cur左子树上最右边的节点，将这个节点记为mostRight，根据mostRight的情况继续分为下面两种情况：
	- 如果mostRight的右孩子为null，则让mostRight的右孩子指向cur，然后cur向左移动，即cur = cur.left。
	- 如果mostRight的右孩子指向cur，则让mostRight的右孩子指回null，然后cur向右移动，即cur = cur.right。

前序遍历：有两个地方含有打印输出语句。第一处是在cur没有左子树的时候，直接打印cur，然后cur向右移动；第二处是在cur有左子树，在**cur向左移动**之前，此时是**第一次遍历**当前节点，故打印cur。

中序遍历：中序遍历的两处打印输出语句，一处是在cur没有左子树的时候，直接打印cur；第二处是在cur有左子树，把当前节点的左子树遍历完了，**cur向右移动**之前，此时是**第二次遍历**到该节点，打印cur。

### [跳表原理](https://www.jianshu.com/p/9d8296562806)🌟🌟
在原始单链表的基础上，每两个节点抽出一个节点，建立第一层索引，第一层索引的节点总数就为 n/2。在第一层索引的节点基础上，每两个节点再抽出一个节点，建立第二层索引，那么第二次索引的节点总数为n/4。类似的方式，我们建立第 k 层索引时，节点总数为n/(2^k))。

**为什么Redis选择跳表**
按照区间来查找数据这个操作，红黑树的效率没有跳表高。按照区间查找数据时，跳表可以做到 O(logn) 的时间复杂度定位区间的起点，然后在原始链表中顺序往后遍历就可以了，非常高效。

### [跳表和B树的区别](https://blog.csdn.net/ljfirst/article/details/112506408)
无法像MySQL那样建立二级索引，那么每一个都是“聚簇索引”。
内存中存的是跳表的每一层数据，页交换容纳的结点小。

### 实现LRU选择哪种数据结构
我们知道HashMap是一个高效的查询数据结构。如果我们将该数据DATA作为键，DATA对应的节点作为值，存储在HashMap中，那么，我们可以得到查询复杂度为O(1)的操作。

LinkedHashMap.LinkedHashMap存放的键值对和存放时的位置一致。不会变化，可以设置LinkedHashMap按照插入的顺序排序，也可以按照访问的顺序排序，最先访问的放置在最后面，最近访问的在最前面。

默认情况下是按照元素的添加顺序存储，也可以启用按照访问顺序存储，即最近读取的数据放在最前面，最早读取的数据放在最后面，然后它还有一个判断是否删除最老数据的方法，默认是返回false，即不删除数据。

### [B树特点](https://blog.csdn.net/yin767833376/article/details/81511377)
1. 每个节点最多有m个孩子。 
2. 除了根节点和叶子节点外，其它每个节点至少有Ceil(m/2)个孩子。 
3. 若根节点不是叶子节点，则至少有2个孩子 
4. 所有叶子节点都在同一层，且不包含其它关键字信息 
5. 每个非终端节点包含n个关键字信息（P0,P1,…Pn, k1,…kn） 
6. 关键字的个数n满足：ceil(m/2)-1 <= n <= m-1 
7. ki(i=1,…n)为关键字，且关键字升序排序。 
8. Pi(i=1,…n)为指向子树根节点的指针。P(i-1)指向的子树的所有节点关键字均小于ki，但都大于k(i-1)

**算法导论的答案：**
B树的最小度数t，t>=2
1. 除了根结点以外的每个结点必须至少有t-1个关键字。除了根结点以外的每个内部结点至少有t个孩子。如果树非空，根节点至少有一个关键字
2. 每个结点至多可以包含2t-1个关键字。因此，一个内部结点至多可以有2t个孩子。当一个结点恰好有2t-1个关键字时，称该结点是满的

如果一个树包含n个关键字（所有的关键字总和），高度为h，最小度数为t
h<=logt((n+1)/2)

B树的分裂：将一个满的结点y(有2t-1个关键字)按其中间关键字分裂成两个各含t-1(2*(t-1)+1)个关键字的结点。中间关键字被提升到y的父结点，以标识两颗新树的划分点。分裂向上传播。
当沿树往下查找新的关键字所属位置时，就分裂沿途遇到的每个满结点（包含叶结点本身）。因此每当要分裂一个满结点y时，就能确保它的父结点不是满的。

### BTree和B+Tree有什么区别？
为什么使用B+Tree作为文件系统的存储方案，有什么优势？
从B-Tree结构图中可以看到每个节点中不仅包含数据的key值，还有data值。而每一个页的存储空间是有限的，如果data数据较大时将会导致每个节点（即一个页）能存储的key的数量很小，当存储的数据量很大时同样会导致B-Tree的深度较大，增大查询时的磁盘I/O次数，进而影响查询效率。
在B+Tree中，所有数据记录节点都是按照键值大小顺序存放在同一层的叶子节点上，而非叶子节点上只存储key值信息，这样可以大大加大每个节点存储的key值数量，降低B+Tree的高度。

B+Tree相对于B-Tree有几点不同：
- 非叶子节点只存储键值信息。
- 所有叶子节点之间都有一个链指针。
- 数据记录都存放在叶子节点中。

[图解B+树的插入过程](https://cloud.tencent.com/developer/article/1461421)

### 哈希索引和B+ 的区别？🐋
- Hash索引不能进行范围查询，而B+树可以
- Hash索引不支持联合索引的最左侧原则（即联合索引的部分索引无法使用），而B+树可以
- Hash索引不支持Order BY排序，而B+树支持
- Hash索引无法进行模糊查询
- Hash索引在等值查询上比B+树效率更高

在InnoDB存储引擎中还有个“自适应Hash索引”的功能，就是当某个索引值使用非常频繁的时候，它会在B+ 树索引的基础上再创建一个Hash索引，就是让B+树也具备了Hash索引的优点。当遇到字段重复度低，而且经常需要进行等值查询的时候，采用Hash索引是个不错的选择。

### B+Tree是如何保持平衡的？

### B树
一个B树的节点通常和一个完整磁盘页一样大，并且磁盘页的大小限制了一个B树结点可以含有的孩子个数。
根节点可以持久地保存在主存中。

### 红黑树
红黑树确保没有一条路径会比其他路径长出两倍
1. 每个节点或是红色的，或是黑色的
2. 根节点是黑色的
3. 每个叶节点（NIL）是黑色的
4. 如果一个节点是红色的，则它的两个子节点都是黑色的
5. 对于每个节点，从该节点到其所有后代节点的简单路径上，均包含相同数目的黑色节点

### 二叉树旋转
[参考](https://www.cnblogs.com/skywang12345/p/3577360.html)