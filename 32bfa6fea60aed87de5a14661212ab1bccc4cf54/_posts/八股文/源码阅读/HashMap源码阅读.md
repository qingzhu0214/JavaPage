### 默认参数
默认初始大小：16
最大容量：1<<30 【1,073,741,824】
默认的装载系数：0.75
链表转换为红黑树的阈值：8【只有当数组容量大于64时才转换】
红黑树转链表的阈值：6

>理想情况下，在随机 hashCodes 下，bin 中节点的频率遵循泊松分布，默认调整大小阈值为 0.75，参数平均约为 0.5，尽管由于调整大小粒度而存在很大差异。 忽略方差，列表大小 k 的预期出现是 (exp(-0.5) * pow(0.5, k) / * factorial(k))。
>
>* 0:    0.60653066
>* 1:    0.30326533
>* 2:    0.07581633
>* 3:    0.01263606
>* 4:    0.00157952
>* 5:    0.00015795
>* 6:    0.00001316
>* 7:    0.00000094
>* 8:    0.00000006

### 计算hash的方法
```java
// 哈希值高16位异或哈希值低16位
(h = key.hashCode()) ^ (h >>> 16);
```

### tableSizeFor(int cap)
```java
// 找到最接近并且大于cap的二进制数
// 新容量为n+1
// 而n是一个类似于01111111的数字，方便通过与操作获取元素在列表中的下标
static final int tableSizeFor(int cap) {
    int n = cap - 1;
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    return (n < 0) ? 1 : (n >= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;
 }
```

### 放置元素的过程
```java
// 查找的下标为：
(n-1) & hash
```

1. 判断列表是否为空，空的话进行resize操作
2. 如果插入元素经过hash得到的位置为空，直接新建一个Node结点放到那个位置
	```java
	tab[i] = newNode(hash, key, value, null);
	```
3. 如果不为空，在hash得到的位置查找结点是否与当前防止的元素相同，如果不相同的话判断当前是红黑树还是列表，并执行插入新结点的过程。如果找到key相同的结点，则修改value为现在新的value
4. 如果当前列表大小大于下一个调整的阈值，则进行resize操作

### Resize()
初始化或加倍表大小。 如果为空，则按照字段阈值中保存的初始容量目标进行分配。 否则返回给定目标容量的2次幂大小。

- 当列表一个位置的元素是单个结点，新容量为原始的两倍，相当于左移一位，在计算hash时，如果一个元素hash值的高位【newCap-1的二进制数中的最左1的下标】为0，则扩容对它不造成影响，还在自己的位置。如果高位为1，则需要移动，新位置等于老位置加上原始容量。

- 当列表一个位置的元素是个链表，遍历链表，并将每个结点通过尾插法放到合适位置。【当前位置或者当前位置偏移原始容量的新位置】。

- 当列表一个位置的元素是个红黑树结点，执行split方法。