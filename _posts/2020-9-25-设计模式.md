代理模式(静态动态，动态的两种方式及区别，cglib缺点我说了final和首次字节码生成的效率)
2. Java设计都用到了什么什么模式
3. 解释一下开闭原则，在哪个地方用了？举个例子，Java的设计有拿着没有遵守这个原则
4. .里氏替换解释一下
5. 单一原则讲一下吧
6. -   工厂模式的设计思路，优缺点
7. 从设计模式出发， 要求写出装饰者模式和策略模式代码。


#### 谈谈Spring中都用到了那些设计模式?🌟
[面试官:“谈谈Spring中都用到了那些设计模式?”。](https://juejin.cn/post/6844903849849962509)
[Spring 中经典的 9 种设计模式，打死也要记住啊！](https://zhuanlan.zhihu.com/p/114244039)
- 工厂设计模式：Spring使用工厂模式可以通过 BeanFactory或 ApplicationContext创建 bean 对象。
- 单例设计模式：Spring 中 bean 的默认作用域就是 singleton(单例)的。
- 代理设计模式：Spring AOP 就是基于动态代理的，如果要代理的对象，实现了某个接口，那么Spring AOP会使用JDK Proxy，去创建代理对象，而对于没有实现接口的对象，就无法使用 JDK Proxy 去进行代理了，这时候Spring AOP会使用Cglib ，这时候Spring AOP会使用 Cglib 生成一个被代理对象的子类来作为代理。
- 模板方法：Spring 中 jdbcTemplate、hibernateTemplate 等以 Template 结尾的对数据库操作的类，它们就使用到了模板模式。
- 观察者模式：Spring 事件驱动模型就是观察者模式很经典的一个应用。
- 适配器模式： Spring AOP 的增强或通知(Advice)使用到了适配器模式。
- 装饰者模式： JDK 中就有很多地方用到了装饰者模式，比如 InputStream家族，InputStream 类下有 FileInputStream (读取文件)、BufferedInputStream (增加缓存,使读取文件速度大大提升)等子类都在不修改InputStream 代码的情况下扩展了它的功能。

#### 开闭原则
**解释一下开闭原则，在哪个地方用了？Java的设计有拿着没有遵守这个原则?**

一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。

#### 里氏替换解释一下
里氏替换原则就是对实现抽象化的具体步骤的规范。即：子类可以扩展基类（父类）的功能，但不能改变父类原有的功能。

#### 单一原则
一个类或者模块只负责完成一个职责（或者功能）。

也就是说，不要设计大而全的类，要设计粒度小、功能单一的类。换个角度来讲就是，一个类包含了两个或者两个以上业务不相干的功能，那我们就说它职责不够单一，应该将它拆分成多个功能更加单一、粒度更细的类。

#### 工厂模式的设计思路，优缺点
[设计模式(二) ——工厂模式 （3种工厂模式的实现及优缺点）](https://blog.csdn.net/love_MyLY/article/details/105499274?spm=1001.2101.3001.6650.2&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-2.pc_relevant_antiscanv2&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-2.pc_relevant_antiscanv2&utm_relevant_index=5)


### 装饰者模式
动态的给一个对象添加一些额外的职责。就增加功能来说，装饰模式相比生成子类更加灵活。
```java
new ConcreteComponentA(new ConcreteComponentB( new ConcreteComponent()))
```

### 策略模式
定义一系列的算法，把他们一个个封装起来，并使它们可以相互替换。本模式使得算法可独立于使用它的客户而变化。
```java
Context ctx = new Context(new ConcreteStrategyA());
ctx.strtegyMethod();

Context ctx = new Context(new ConcreteStrategyB());
ctx.strtegyMethod();
```

### 单例模式的懒汉式和饿汉式🌟🌟
[参考](https://blog.csdn.net/fly910905/article/details/79286680)

```java
// 饿汉模式
public final class Singleton {
    private static Singleton instance=new Singleton();// 自行创建实例
    private Singleton(){}// 构造函数
    public static Singleton getInstance(){// 通过该函数向整个系统提供实例
        return instance;
    }
}
```
类的构造函数定义为private的，保证其他类不能实例化此类，然后提供了一个静态实例并返回给调用者。饿汉模式是最简单的一种实现方式，饿汉模式在类加载的时候就对实例进行创建，实例在整个程序周期都存在。

-   它的**好处**是只**在类加载的时候创建一次实例**，不会存在多个线程创建多个实例的情况，**避免了多线程同步的问题**。
-   它的**缺点**也很明显，即使这个单例没有用到也会被创建，而且在类加载之后就被创建，**内存就被浪费**了。

```java
// 懒汉模式
public final class Singleton {
    private static Singleton instance= null;// 不实例化
    private Singleton(){}// 构造函数
    public static Singleton getInstance(){// 通过该函数向整个系统提供实例
        if(null == instance){// 当 instance 为 null 时，则实例化对象，否则直接返回对象
            instance = new Singleton();// 实例化对象
        }
        return instance;// 返回已存在的对象
    }
}
```
懒汉模式中单例是在需要的时候才去创建的。但是这里的懒汉模式并没有考虑线程安全问题，在多个线程可能会并发调用它的getInstance()方法，导致创建多个实例，因此需要加锁解决线程同步问题。

**双重校验锁**

假如两个线程A、B，A执行了if (instance == null)语句，它会认为单例对象没有创建，此时线程切到B也执行了同样的语句，B也认为单例对象没有创建，然后两个线程依次执行同步代码块，并分别创建了一个单例对象。为了解决这个问题，还需要在同步代码块中增加if (instance == null)语句。

在JDK1.5及之后版本增加了volatile关键字。volatile的一个语义是禁止指令重排序优化，也就保证了instance变量被赋值的时候对象已经是初始化过的。

```java
// 懒汉模式 + synchronized 同步锁 + double-check
public final class Singleton {
    private volatile static Singleton instance= null;// 不实例化
    private Singleton(){}// 构造函数
    public static Singleton getInstance(){// 加同步锁，通过该函数向整个系统提供实例
        if(null == instance){// 第一次判断，当 instance 为 null 时，则实例化对象，否则直接返回对象
          synchronized (Singleton.class){// 同步锁
             if(null == instance){// 第二次判断
                instance = new Singleton();// 实例化对象
             }
          } 
        }
        return instance;// 返回已存在的对象
    }
}
```

**静态内部类**
```java
// 懒汉模式 内部类实现
public final class Singleton {
	public List<String> list = null;// list 属性
 
	private Singleton() {// 构造函数
		list = new ArrayList<String>();
	}
 
	// 内部类实现
	public static class InnerSingleton {
		private static Singleton instance=new Singleton();// 自行创建实例
	}
 
	public static Singleton getInstance() {
		return InnerSingleton.instance;// 返回内部类中的静态变量
	}
}
```

**枚举**
```java

public class EnumSingleton{
    private EnumSingleton(){}
    public static EnumSingleton getInstance(){
        return Singleton.INSTANCE.getInstance();
    }
    private static enum Singleton{
        INSTANCE;
        private EnumSingleton singleton;
        //JVM会保证此方法绝对只调用一次
        private Singleton(){
            singleton = new EnumSingleton();
        }
        public EnumSingleton getInstance(){
            return singleton;
        }
    }
}
```

### 代理模式
[Java三种代理模式：静态代理、动态代理和cglib代理](https://segmentfault.com/a/1190000011291179)

代理模式可以在不修改被代理对象的基础上，通过扩展代理类，进行一些功能的附加与增强。值得注意的是，代理类和被代理类应该共同实现一个接口，或者是共同继承某个类。

### 建造者模式
在用户不知道对象的建造过程和细节的情况下就可以直接创建复杂的对象。
