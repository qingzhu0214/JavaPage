ApplyRequest：申请日期，申请理由，申请的审批状态，在继承的类里面才会有具体的实体，例如DataRule
AuditFlowStep：模块名称，模块key，审批步骤，审批角色，审批部门，拒绝动作
AuditRecord\<ApplyRequestClass extends ApplyRequest> 泛型类：需要审批的申请，对应的审批流程，审批人，审批日期，审批理由，申请的审批状态

### 使用泛型抽象出审批表
用了**泛型**就可以把具体的申请实体传进来，生成对应的带有外键的数据库表。

[参考](https://www.programminghunter.com/article/9660901064/)
如果按照传统JPA方法，就需要建立N个Entity，N个Repository，N个查询方法。使用SpEL表达式可以简化Entity及Repository中的代码编写，只需要在抽象出来的repository中编写。
```java
@NoRepositoryBean
public interface MappedTypeRepository<T extends AbstractMappedType>
extends Repository<T, Long> {
	// '#{#entityName}'值为'T'对象对应的数据表名称
	@Query("select t from #{#entityName} t where t.id = ?1")
	List<T> findById(int id);
	
	@Query("select t from #{#entityName} t ")
	List<T> findALL();
}
```


#### AuditSubscriber：
包含onRequestSummited、onRejectAudit、onPassAudit、onPassRequest、onRejectRequest

### AuditFlowExecutor：
**submitApplyWithAuditFlow：根据审批流程生成审批记录**
- List\<AuditFlowStep> 找到符合的审批步骤，如果审批步骤为空的话,直接通过申请
- 不为空的话生成对应的审批记录AuditRecord，第一条显示审批中，其他都是待审批
- 生成对应的审批记录AuditRecord用到了**反射**，通过传入类的构造方法生成实例
- 保存这些记录，执行onRequestSummited方法

```java
// 反射
record = (AuditRecord) auditRecordClass.getDeclaredConstructor().newInstance();
```

**auditRequest：点击通过或者拒绝**
- 通过auditId获取AuditRecord
- 通过的话调用passAudit方法，将记录的审批字段改成通过
- 找到同一层级的其他人审批的记录全都改成通过【比如说辅导员A审批了B就不用审批】
- 将下一个审批的步骤改成审批中，如果现在已经是最后一步，就通过申请

**rejectAudit：拒绝审批**
1. 允许拒绝：意味着当前步骤可以被不断审批【可以重新修改申请，直接提交到当前的审批步骤】
	- 把当前的auditRecord改成否决
	- 把ApplyRequest的状态改成否决

2. 修改重新审批：审批拒绝时，可以重新修改申请，这时当前审批步骤之前的所有流程必须重新审批一遍
	- 把当前的auditRecord改成否决
	- 把ApplyRequest的状态改成否决
	- 比上面多了一条`applyRequest.setEditable(true);` // 学生是否可以修改申请
	- 重置前面的审批状态，都改成待审批【<=seq】
	- 执行 subscriber.onRejectAudit方法

3. 拒绝申请：审批终止，申请被拒绝
	- 把后续的审批都改成否决
	- 执行subscriber.onRejectRequest方法

### DataRuleAuditFlowExecutor
```java
// 只有实现类是bean，父类不标注
@Service
public class DataRuleAuditFlowExecutor extends AuditFlowExecutor implements AuditSubscriber
```

实现onPassRequest、onRejectRequest等方法

用构造器注入把一些继承类注入进来
```java
@Autowired
public void setRepository(DataRuleAuditRepository auditRepo,
						  DataRuleRequestRepository requestRepo,
						  AuditFlowRepository auditFlowRepository) {
	this.auditRecordRepository = auditRepo;
	this.applyRequestRepository = requestRepo;
	this.auditFlowRepository = auditFlowRepository;
	this.subscriber = this;
}
```

### AuditRecordRepository
// 这样spring容器中就不会有BaseReposytory接口的bean对象
@NoRepositoryBean
AuditRecordRepository\<T extends AuditRecord>

DataRuleAuditRepository继承了AuditRecordRepository


### 类的关系
```java
// 标注为@MappedSuperclass的类将不是一个完整的实体类，他将不会映射到数据库表，但是他的属性都将映射到其子类的数据库字段中。
@MappedSuperclass
public class AuditRecord<ApplyRequestClass extends ApplyRequest> extends EntityId

@MappedSuperclass
public abstract class ApplyRequest extends EntityId



// 这样spring容器中就不会有BaseReposytory接口的bean对象
@NoRepositoryBean
public interface AuditRecordRepository<T extends AuditRecord>
        extends JpaRepository<T, Long>, JpaSpecificationExecutor<T>

// 因为JpaRepository需要具体的实体，所以传入的时候需要用泛型传入T
@NoRepositoryBean
public interface ApplyRequestRepository<T extends ApplyRequest>
        extends JpaRepository<T, Long>, JpaSpecificationExecutor<T>

		
        
public interface DataRuleAuditRepository extends AuditRecordRepository<DataRuleAudit>

public interface DataRuleRequestRepository extends ApplyRequestRepository<DataRuleRequest>

// 请求里包含了具体的请求对象
@Entity
public class DataRuleRequest extends ApplyRequest 

// 审批里包含了对应的请求
@Entity
public class DataRuleAudit extends AuditRecord<DataRuleRequest>
```


### 泛型类
在初始化一个泛型类时，使用 <> 指定了内部具体类型，在编译时就会根据这个类型做强类型检查。

不同于 C++ 的模板机制，Java 泛型是使用类型擦除来实现的，使用泛型时，任何具体的类型信息都被擦除了。把泛型中的所有类型参数替换为 Object，如果指定类型边界，则使用类型边界来替换。因此，生成的字节码仅包含普通的类，接口和方法。

关于泛型变量的使用，是会在编译之前检查的。
