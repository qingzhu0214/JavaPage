### 怎么解决分布式缓存初期过冷的问题？

### 分布式一致性算法Raft

### [分布式锁](https://segmentfault.com/a/1190000038988087)
[参考链接](https://juejin.cn/post/6844903688088059912)

Redis因为单进程、性能高的特点，它还经常被用于做分布式锁。
分布式锁需要满足的特性有这么几点：
1. 互斥性：在任何时刻，对于同一条数据，只有一台应用可以获取到分布式锁；
2. 高可用性：在分布式场景下，一小部分服务器宕机不影响正常使用，这种情况就需要将提供分布式锁的服务以集群的方式部署；
3. 防止锁超时：如果客户端没有主动释放锁，服务器会在一段时间之后自动释放锁，防止客户端宕机或者网络不可达时产生死锁；
4. 独占性：加锁解锁必须由同一台服务器进行，也就是锁的持有者才可以释放锁，不能出现你加的锁，别人给你解锁了；

Redis的几个命令：
1. SETNX，用法是`SETNX key value` ：（如果不存在，则 SET）
2. `EXPIRE Key Seconds`
3. SETEX，用法`SETEX key seconds value` ：将值 value 关联到 key ，并将 key 的生存时间设为 seconds (以秒为单位)。如果 key 已经存在，SETEX 命令将覆写旧值。
4. `SET key value NX EX seconds` 

分布式锁的缺陷：
1. 客户端长时间阻塞导致锁失效问题
2. redis服务器时钟漂移问题
3. 单点实例安全问题

RedLock算法：该算法的实现前提在于Redis必须是多节点部署的，可以有效防止单点故障
1. 获取当前时间戳（ms）
2. 先设定key的有效时长（TTL），超出这个时间就会自动释放，然后client（客户端）尝试使用相同的key和value对所有redis实例进行设置，每次链接redis实例时设置一个比TTL短很多的超时时间，这是为了不要过长时间等待已经关闭的redis服务。并且试着获取下一个redis实例。
3. client通过获取所有能获取的锁后的时间减去第一步的时间，还有redis服务器的时钟漂移误差，然后这个时间差要小于TTL时间并且成功设置锁的实例数>= N/2 + 1（N为Redis实例的数量），那么加锁成功。
4. 如果客户端由于某些原因获取锁失败，便会开始解锁所有redis实例。

### 分布式系统的CAP理论🐋
[参考](https://zhuanlan.zhihu.com/p/33999708)
- Consistency 一致性即所有节点在同一时间的数据完全一致。对于一致性，可以分为强/弱/最终一致性三类。
	- 对于关系型数据库，要求更新过的数据能被后续的访问都能看到，这是强一致性。
	- 如果能容忍后续的部分或者全部访问不到，则是弱一致性。
	- 如果经过一段时间后要求能访问到更新后的数据，则是最终一致性。
- Availability 可用性：即服务在正常响应时间内一直可用。好的可用性主要是指系统能够很好的为用户服务，不出现用户操作失败或者访问超时等用户体验不好的情况。
- Partition Tolerance分区容错性：即分布式系统在遇到某节点或网络分区故障的时候，仍然能够对外提供满足一致性或可用性的服务。

对于多数大型互联网应用的场景，要保证服务可用性达到N个9，即保证P和A，舍弃C（退而求其次保证最终一致性）。虽然某些地方会影响客户体验，但没达到造成用户流程的严重程度。

对于涉及到钱财这样不能有一丝让步的场景，C必须保证。