代理模式(静态动态，动态的两种方式及区别，cglib缺点我说了final和首次字节码生成的效率)
2. Java设计都用到了什么什么模式
3. 解释一下开闭原则，在哪个地方用了？举个例子，Java的设计有拿着没有遵守这个原则
4. .里氏替换解释一下
5. 单一原则讲一下吧
6. -   工厂模式的设计思路，优缺点
7. 从设计模式出发， 要求写出装饰者模式和策略模式代码。


#### 谈谈Spring中都用到了那些设计模式?🌟
[面试官:“谈谈Spring中都用到了那些设计模式?”。](https://juejin.cn/post/6844903849849962509)
[Spring 中经典的 9 种设计模式，打死也要记住啊！](https://zhuanlan.zhihu.com/p/114244039)
- 工厂设计模式：Spring使用工厂模式可以通过 BeanFactory或 ApplicationContext创建 bean 对象。
- 单例设计模式：Spring 中 bean 的默认作用域就是 singleton(单例)的。
- 代理设计模式：Spring AOP 就是基于动态代理的，如果要代理的对象，实现了某个接口，那么Spring AOP会使用JDK Proxy，去创建代理对象，而对于没有实现接口的对象，就无法使用 JDK Proxy 去进行代理了，这时候Spring AOP会使用Cglib ，这时候Spring AOP会使用 Cglib 生成一个被代理对象的子类来作为代理。
- 模板方法：Spring 中 jdbcTemplate、hibernateTemplate 等以 Template 结尾的对数据库操作的类，它们就使用到了模板模式。
- 观察者模式：Spring 事件驱动模型就是观察者模式很经典的一个应用。
- 适配器模式： Spring AOP 的增强或通知(Advice)使用到了适配器模式。
- 装饰者模式： JDK 中就有很多地方用到了装饰者模式，比如 InputStream家族，InputStream 类下有 FileInputStream (读取文件)、BufferedInputStream (增加缓存,使读取文件速度大大提升)等子类都在不修改InputStream 代码的情况下扩展了它的功能。

#### 开闭原则
**解释一下开闭原则，在哪个地方用了？Java的设计有拿着没有遵守这个原则?**
【泛型类吧】

一个软件实体如类、模块和函数应该**对扩展开放，对修改关闭。**

#### 里氏替换解释一下
里氏替换原则就是对实现抽象化的具体步骤的规范。即：子类可以扩展基类（父类）的功能，但不能改变父类原有的功能。

#### 单一原则
一个类或者模块只负责完成一个职责（或者功能）。

也就是说，不要设计大而全的类，要设计粒度小、功能单一的类。换个角度来讲就是，一个类包含了两个或者两个以上业务不相干的功能，那我们就说它职责不够单一，应该将它拆分成多个功能更加单一、粒度更细的类。

#### 工厂模式的设计思路，优缺点
[设计模式(二) ——工厂模式 （3种工厂模式的实现及优缺点）](https://blog.csdn.net/love_MyLY/article/details/105499274?spm=1001.2101.3001.6650.2&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-2.pc_relevant_antiscanv2&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-2.pc_relevant_antiscanv2&utm_relevant_index=5)

***
[写的不错](https://juejin.cn/post/6844903474639929357)
和简单工厂对比一下，最根本的区别在于，**简单工厂只有一个统一的工厂类**，而工厂方法是**针对每个要创建的对象都会提供一个工厂类**，这些工厂类都实现了一个工厂基类。

抽象工厂模式是工厂方法的仅一步深化，在这个模式中的工厂类**不单单可以创建一个对象，而是可以创建一组对象**。这是和工厂方法最大的不同点。

### 装饰者模式
动态的给一个对象添加一些额外的职责。就增加功能来说，装饰模式相比生成子类更加灵活。
```java
new ConcreteComponentA(new ConcreteComponentB( new ConcreteComponent()))
```

### 策略模式
定义一系列的算法，把他们一个个封装起来，并使它们可以相互替换。本模式使得算法可独立于使用它的客户而变化。
```java
Context ctx = new Context(new ConcreteStrategyA());
ctx.strtegyMethod();

Context ctx = new Context(new ConcreteStrategyB());
ctx.strtegyMethod();
```

### 单例模式的懒汉式和饿汉式🌟🌟
[参考](https://blog.csdn.net/fly910905/article/details/79286680)

```java
// 饿汉模式
public final class Singleton {
    private static Singleton instance=new Singleton();// 自行创建实例
    private Singleton(){}// 构造函数
    public static Singleton getInstance(){// 通过该函数向整个系统提供实例
        return instance;
    }
}
```
类的构造函数定义为private的，保证其他类不能实例化此类，然后提供了一个静态实例并返回给调用者。饿汉模式是最简单的一种实现方式，饿汉模式在类加载的时候就对实例进行创建，实例在整个程序周期都存在。

-   它的**好处**是只**在类加载的时候创建一次实例**，不会存在多个线程创建多个实例的情况，**避免了多线程同步的问题**。
-   它的**缺点**也很明显，即使这个单例没有用到也会被创建，而且在类加载之后就被创建，**内存就被浪费**了。

```java
// 懒汉模式
public final class Singleton {
    private static Singleton instance = null;// 不实例化
    private Singleton(){}// 构造函数
    public static Singleton getInstance(){// 通过该函数向整个系统提供实例
        if(null == instance){// 当 instance 为 null 时，则实例化对象，否则直接返回对象
            instance = new Singleton();// 实例化对象
        }
        return instance;// 返回已存在的对象
    }
}
```
懒汉模式中单例是在需要的时候才去创建的。但是这里的懒汉模式并没有考虑线程安全问题，在多个线程可能会并发调用它的getInstance()方法，导致创建多个实例，因此需要加锁解决线程同步问题。

**双重校验锁**
假如两个线程A、B，A执行了if (instance == null)语句，它会认为单例对象没有创建，此时线程切到B也执行了同样的语句，B也认为单例对象没有创建，然后两个线程依次执行同步代码块，并分别创建了一个单例对象。为了解决这个问题，还需要在同步代码块中增加if (instance == null)语句。

在JDK1.5及之后版本增加了volatile关键字。volatile的一个语义是禁止指令重排序优化，也就保证了instance变量被赋值的时候对象已经是初始化过的。【由于指令重排优化的存在，导致初始化Singleton和将对象地址赋给instance字段的顺序是不确定的。虽然分配的内存地址赋值给instance字段了，然而该对象可能还没有初始化。若紧接着另外一个线程来调用getInstance，取到的就是状态不正确的对象，程序就会出错。】

```java
// 懒汉模式 + synchronized 同步锁 + double-check
public final class Singleton {
    private volatile static Singleton instance = null;// 不实例化
    private Singleton(){}// 构造函数
    public static Singleton getInstance(){// 加同步锁，通过该函数向整个系统提供实例
        if(null == instance){// 第一次判断，当 instance 为 null 时，则实例化对象，否则直接返回对象
          synchronized (Singleton.class){// 同步锁
             if(null == instance){// 第二次判断
                instance = new Singleton();// 实例化对象
             }
          } 
        }
        return instance;// 返回已存在的对象
    }
}
```

**静态内部类**
```java
// 懒汉模式 内部类实现
public final class Singleton {
	private Singleton() {// 构造函数
	}
 
	// 内部类实现
	public static class InnerSingleton {
		private static Singleton instance=new Singleton();// 自行创建实例
	}
 
	public static Singleton getInstance() {
		return InnerSingleton.instance;// 返回内部类中的静态变量
	}
}
```

**枚举**
```java

public class EnumSingleton{
    private EnumSingleton(){}
    public static EnumSingleton getInstance(){
        return Singleton.INSTANCE.getInstance();
    }
    private static enum Singleton{
        INSTANCE;
        private EnumSingleton singleton;
        //JVM会保证此方法绝对只调用一次
        private Singleton(){
            singleton = new EnumSingleton();
        }
        public EnumSingleton getInstance(){
            return singleton;
        }
    }
}
```

### 什么时候能用到单例模式
一些配置类

### 单例模式被破坏的情况
[参考](https://blog.csdn.net/LIZHONGPING00/article/details/104855109)
反射：
可以在构造器中添加反射防御代码，让它在被要求创建第二个实例时抛出异常。
```java
private ReflectSingleton() {
    if (instance != null) {
        throw new RuntimeException("禁止反射调用创建多个实例");
    }
}
```

序列化和反序列化
添加readResolve()方法
```java
private Object readResolve() {
    return instance;
}
```
如果SerializeSingleton类中定义了readResolve方法，就通过反射创建原实例，返回时覆盖之前创建的实例。否则，返回新的实例。

### 枚举单例
```java
public final class Singleton {
    private Singleton(){
    }   
    public static enum SingletonEnum {
        SINGLETON;
        private Singleton instance = null;
        private SingletonEnum(){
            instance = new Singleton();
        }
        public Singleton getInstance(){
            return instance;
        }
    }
}
```

### 代理模式
[Java三种代理模式：静态代理、动态代理和cglib代理](https://segmentfault.com/a/1190000011291179)

代理模式可以在不修改被代理对象的基础上，通过扩展代理类，进行一些功能的附加与增强。值得注意的是，代理类和被代理类应该共同实现一个接口，或者是共同继承某个类。

### 建造者模式
.builder()
中间过程的set方法都return this，最后的build方法创建一个对象`return new Computer(this);`
在用户不知道对象的建造过程和细节的情况下就可以直接创建复杂的对象。

### 装饰模式 策略模式 观察者模式
[参考](https://blog.csdn.net/liuguangxu1988/article/details/82055853)

策略模式的结构其实非常简单，比模板方法模式简单多了，它实质上就是一个原则的体现，往低里说就是里式替换原则，往高里说是依赖倒置原则，具体实现过程是这样：
- 有一个接口A中有一个抽象算法方法a
- 有一组接口A的实现类A* 用不同具体算法实现了抽象算法方法a
- 在客户端里先持有一个算法接口的引用，在要调用某个算法方法时，你就给这个引用赋实现类的值，然后通过这个引用调用相应算法方法就可以了

```java
//定义一个统一接口用于依赖
public interface IDevice
{
	void Login();
	bool Spider();
}
//MML类型的设备
public class DeviceMML : IDevice
{
	public void Login()
	{
		Console.WriteLine("MML设备登录");
	}

	public bool Spider()
	{
		Console.WriteLine("MML设备采集");
		return true;
	}
}
//设备采集的服务
public class DeviceService
{
	private IDevice m_device;
	public DeviceService(IDevice oDevice)
	{
		m_device = oDevice;
	}

	public void LoginDevice()
	{
		m_device.Login();
	}

	public bool DeviceSpider()
	{
		return m_device.Spider();
	}
}
// 调用
static void Main(string[] args)
{
	var oSpider = new DeviceService(new DeviceTL5());
	oSpider.Login();
	var bRes = oSpider.Spider();

	Console.ReadKey();
}
```

模板方法模式：
- 有一个抽象类A中有两个方法（暂时忽略钩子方法），抽象算法方法a-abstruct，模板业务方法a-mode（模板方法中使用到了抽象算法方法，所以其实这个模板方法现在还不能正常工作）
- 在客户端里要使用这个类时，继承抽象类，并实现抽象算法方法，然后实例化使用

```java
// 抽象类，表示豆浆	SoyaMilk.java
public abstract class SoyaMilk {
	// 模板方法：可以做成final，不让子类去覆盖
	final void make() {
		select();
		addCondiment();
		soak();
		beat();
	}
	
	//选材料
	void select() { System.out.println("第一步：选择新鲜的豆子"); }
	//添加不同的配料：抽象方法，由子类具体实现
	abstract void addCondiment();
	//浸泡
	void soak() { System.out.println("第三步：豆子和配料开始浸泡3H"); }
	//榨汁
	void beat() { System.out.println("第四步：豆子和配料放入豆浆机榨汁"); }
}

public class ReadBeanSoyaMilk extends SoyaMilk {
	@Override
	void addCondiment() {
		System.out.println("第二步：加入上好的红豆");
	}
}

public class PeanutSoyaMilk extends SoyaMilk {
	@Override
	void addCondiment() {
		System.out.println("第二步：加入上好的花生");
	}
}

public class Client {
	public static void main(String[] args) {
		System.out.println("=======制作红豆豆浆=======");
		SoyaMilk redBeanSoyaMilk = new ReadBeanSoyaMilk();
		redBeanSoyaMilk.make();
		
		System.out.println("=======制作花生豆浆=======");
		SoyaMilk peanutSoyaMilk = new PeanutSoyaMilk();
		peanutSoyaMilk.make();
	}
}
```

```java
users = jdbcTemplate.query(sql, params,  
                new RowMapper<User>() {  
                    @Override  
                    public User mapRow(ResultSet rs, int rowNum) throws SQLException {  
                        User user = new User();  
                        user.setId(rs.getInt("id"));  
                        user.setUsername(rs.getString("username"));  
                        user.setPassword(rs.getString("password"));  
                        return user;  
                    }  
                });  
```
[参考](https://blog.csdn.net/qq_26222859/article/details/80292663)
为什么spring不用传统的模板方法，而加之以Callback进行配合呢？ 
试想，如果父类中有10个抽象方法，而继承它的所有子类则要将这10个抽象方法全部实现，子类显得非常臃肿。而有时候某个子类只需要定制父类中的某一个方法该怎么办呢？这个时候就要用到Callback回调了。

### JDBCTemplate
[参考](https://blog.csdn.net/qq_26222859/article/details/80292663)
RowMapper接口负责处理某一行的数据，例如，我们可以在mapRow方法里对某一行记录进行操作，或封装成entity。 
ResultSetExtractor是数据集抽取器，负责遍历ResultSet并根据RowMapper里的规则对数据进行处理。 
RowMapper和ResultSetExtractor区别是， RowMapper是处理某一行数据，返回一个实体对象 。而 ResultSetExtractor是处理一个数据集合，返回一个对象集合 。

### 装饰器和适配器的区别
适配器模式的意义是要将一个接口转变成另一个接口，它的目的是通过改变接口来达到重复使用的目的。 

而装饰器模式不是要改变被装饰对象的接口，而是恰恰要保持原有的接口，但是增强原有对象的功能，或者改变原有对象的处理方式而提升性能。

### 设计模式6大原则
单一职责原则（类和方法，接口）

开闭原则 （扩展开放，修改关闭）

里氏替换原则（基类和子类之间的关系）

依赖倒置原则（依赖抽象接口，而不是具体对象）

接口隔离原则（接口按照功能细分）

迪米特法则 （类与类之间的亲疏关系）