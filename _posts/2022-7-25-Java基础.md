HashMap
**hashMap put get过程**
    
**hashp什么时候退回回[链表](/jump/super-jump/word?word=%E9%93%BE%E8%A1%A8)？为什么不是7**
    
**取模的时候为什么用&(length-1)**容量不是2的整数次幂 还用&(length-1) 影响会怎样？**
    
**容量不是2的整数次幂 还用&(length-1) 影响会怎样？：容量是2的整数次幂，n -1 后，高位为1后的0都变为1，如 16：10000, 16-1=15：1111, 1111 再与 hash 做 & 运算的时候，各个位置的取值取决于 hash；如果不是2的整数次幂，必然会有的0的位，0与任何数&肯定为0，会造成更多的哈希冲突**

[哈希表](https://www.nowcoder.com/jump/super-jump/word?word=%E5%93%88%E5%B8%8C%E8%A1%A8)的作用 [哈希表](https://www.nowcoder.com/jump/super-jump/word?word=%E5%93%88%E5%B8%8C%E8%A1%A8)使用的数据结构 哈希内部解决哈希冲突的方式有哪几种
hashmap原理,扩容,问了我hashmap怎么缩容
hashtable hashmap synchronizedmap concurrentmap
为什么负载因子是0.75
HashMap八股（数据结构，扩容，[链表](https://www.nowcoder.com/jump/super-jump/word?word=%E9%93%BE%E8%A1%A8)和[红黑树](https://www.nowcoder.com/jump/super-jump/word?word=%E7%BA%A2%E9%BB%91%E6%A0%91)转换）
有哪些线程安全的集合类，讲一讲原理（HashTable，ConcurrentHashMap，CopyOnWriteArrayList）

1.  ArrayList、Linkedlist
2. ArrayList和LinkedList区别
3.  HashMap、HashTable
4. 实现String的equals()
5.  [一致性哈希算法](https://www.nowcoder.com/jump/super-jump/word?word=%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95)
Java里的Map有哪几种实现
(HashMap | TreeMap | HashTable | LinkedHashMap | ConcurrentHashMap)
 TreeMap的使用场景，底层数据结构，[红黑树](https://www.nowcoder.com/jump/super-jump/word?word=%E7%BA%A2%E9%BB%91%E6%A0%91)的存取复杂度
LinkedHashMap的使用场景

(用LinkedHashMap实现lru，按插入顺序(默认) accessOrder = false | 按访问顺序 accessOrder = true，HashMap+双向[链表](/jump/super-jump/word?word=%E9%93%BE%E8%A1%A8))

Java中常用的集合类  
(先说Collection和Map接口，再分别说子接口和实现类，以及大概的区别，没让细讲源码)
HashMap 多线程下，怎么个个不安全法，数据丢失问题。
 
多线程
1.  多线程环境下为什么要引入同步的机制
2. 1.  java内部有哪些同步的机制 回答 synchronized 和 retrenlock 问 这两种锁有哪些区别
3. 1.  多线程什么场景下会发生死锁
4. 1.  有什么具体的办法可以避免死锁
5. volatile的作用和原理  
什么是原子性  
volatile能不能保证原子性
 finally的实现原理
 1.  volatile的理解

乐观锁和悲观锁
  
Java中有个volatile关键字用过吗，用volatile修饰的变量来记录访问次数，需要其他同步操作吗

(场景：单例模式等，参考《深入理解Java虚拟机》第12章12.3.3“对于volatile型变量的特殊规则”，从Java内存模型JMM的角度讲volatile，说明指令中的lock前缀和将esp寄存器的值+0这个空操作)

Java有哪些同步方案，如果不加锁呢，加锁会不会太重了

(参考《深入理解Java虚拟机》第13章第2节，从“阻塞同步方案 | 非阻塞同步方案 | 无同步方案”三部分说明，面试官提到加锁会不会太重的时候，我提了一下synchronized锁升级)

CAS的ABA问题是什么，要怎么解决
(参考《深入理解Java虚拟机》P477)

 有没有用过工具，怎么查看Java堆的统计信息
(参考《深入理解Java虚拟机》第4章，没用过工具，只说了常用了JVM参数)

Java中线程同步的方案有哪些  
(参考《深入理解Java虚拟机》第13章第2节，从“阻塞同步方案 | 非阻塞同步方案 | 无同步方案”三部分说明)
  
Lock接口的实现类  
(参考《Java并发编程的艺术》第5章，Lock接口的实现基本都是通过聚合了一个同步器的子类来完成线程访问控制的，引出了队列同步器AQS，实现类讲了ReentrantLock和ReentrantReadWriteLock)
  
-   面向对象和面向过程的区别
-   接口和抽象类的区别
-   多态的分类
-   异常体系
-   finally 的作用
-   如果在 finally 块中有 return 语句，发生异常会执行吗？不发生呢？
-   ArrayList 的扩容过程
-   非线程安全的集合怎么改为线程安全

volatile关键字的作用（引出Java内存模型，保证可见性，防止指令重[排序](https://www.nowcoder.com/jump/super-jump/word?word=%E6%8E%92%E5%BA%8F)）  
mesi协议  
内存屏障

3.从可重入锁出发， 要求写出基于可重入锁的阻塞队列，怎么实现。
4.从volatile出发， 要求写出volatile解决可见性的代码。


 3. 1.  继承，接口，抽象类区别？
1.  数组[链表](https://www.nowcoder.com/jump/super-jump/word?word=%E9%93%BE%E8%A1%A8)区别
反射
虚继承

深拷贝和浅拷贝区别


## HashMap底层机制🌟🌟🌟
[参考](https://www.cnblogs.com/niumoo/p/12602849.html)
### HashMap get和put过程
put过程：
1. 先计算出key对应的hashCode
2. 对hash值进行处理：高16位与低16位异或
3. 根据hash值计算出index值，也就是所在链表的头节点：index=hash&(table.length-1)
4. 如果hash值在hashMap中不存在，则执行插入，否则：
	1. 如果hash值存在，且两者equals返回true，则更新键值对
	2. equals返回false，则插入链表的尾部或者红黑树中。
5. 将存储元素数量+1
6. 检验是否需要扩容

get过程：
1. 计算key的hash值，获得该键值所在链表的数组下标
2. 顺序遍历链表，equals方法查找链表中K值对应的V值

### HashMap什么时候退回链表?为什么不是7？
1.  扩容 resize() 时，红黑树拆分成的树的结点数小于等于临界值6个，则退化成链表。
2. 移除元素 remove( ) 时，在removeTreeNode() 方法会检查红黑树是否满足退化条件，与结点数无关。如果红黑树根 root 为空，或者 root 的左子树/右子树为空，root.left.left 根的左子树的左子树为空，都会发生红黑树退化成链表。

至于7，是为了作为缓冲，可以有效防止链表和树频繁转换。

### 容量不是2的整数次幂，还用&(length-1) 影响会怎样？
- 假如不是按2的幂次方，随便假设为length = 15，hash= 17，则10进制取余运算为2，二进制位运算为10001&01110 =0，**不会等于10进制的运算结果**；
- 而实际上length-1 = 14 = 01110和任何的hash相与，**最后的一位的0都会被舍弃**，所以任何的hash值和01110相与的结果都不会出现1101（13），1001（9）等数据（相当于与运算结果最后一位不会是1），所以相当于table的数组中index =13或者9的位置**永远不会保存到数据**，造成空间浪费；
- 所以就不能用位运算计算key对应的value的值，就要用10进制计算，速度就比不上二进制算法；

### 哈希表的作用，使用的数据结构
哈希表通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。
数组、链表和红黑树。

### 哈希内部解决哈希冲突的方式有哪几种？🌟🌟

**开放定址法（再散列法）：**

当关键字key的哈希地址p = H（key）出现冲突时，以p为基础，产生另一个哈希地址p1，如果p1仍然冲突，再以p为基础，产生另一个哈希地址p2，…，直到找出一个不冲突的哈希地址pi ，将相应元素存入其中。

线性探测：冲突发生时，顺序查看表中下一单元，直到找出一个空单元或查遍全表。
平方探测：冲突发生时，在表的左右进行跳跃式探测(1，-1，4，-4，9，-9)，比较灵活。
伪随机探测再散列：应建立一个伪随机数发生器，（如i=(i+p) % m），并给定一个随机数做起点。i为H(key)，p的值可以是(1,2,3...)也可以是(1，-1，4，-4...)，也可以是个随机数序列(2,5,9...)

**再哈希法**
同时构造多个不同的哈希函数，当哈希地址发生冲突时，计算第二个哈希地址。这种方法不易产生聚集，但增加了计算时间。

**链地址法**

**建立公共溢出区**
将哈希表分为基本表和溢出表两部分，凡是和基本表发生冲突的元素，一律填入溢出表。

与开放定址法相比，链地址法有如下几个优点：
1. 链地址法处理冲突简单，且无堆积现象，即非同义词决不会发生冲突，因此平均查找长度较短；
2. 由于链地址法中各链表上的结点空间是动态申请的，故它更适合于造表前无法确定表长的情况；
3. 开放定址法为减少冲突，要求装填因子α较小，故当结点规模较大时会浪费很多空间。而链地址法中可取α≥1，且结点较大时，链地址法中增加的指针域可忽略不计，因此节省空间；
4. 用链地址法构造的散列表中，删除结点的操作易于实现。只要简单地删去链表上相应的结点即可。而对开放地址法构造的散列表，删除结点不能简单地将被删结点的空间置为空，否则将截断在它之后填入散列表的同义词结点的查找路径。这是因为各种开放地址法中，空地址单元(即开放地址)都是查找失败的条件。因此在用开放地址法处理冲突的散列表上执行删除操作，只能在被删结点上做删除标记，而不能真正删除结点。

链地址法的缺点是：指针需要额外的空间，故当结点规模较小时，开放定址法较为节省空间，而若将节省的指针空间用来扩大散列表的规模，可使装填因子变小，这又减少了开放定址法中的冲突，从而提高平均查找速度。

### HashMap底层为什么要用红黑树呢？为什么不用平衡二叉树？
[参考](https://www.cnblogs.com/wq-9/articles/14202773.html)
红黑树是许多二叉查找树中的一种，它能保证在最坏的情况下，基本动态集合操作时间为O(lgn)。

红黑树是用非严格的平衡来换取增删节点时候旋转次数的降低，任何不平衡都会在三次旋转之内解决，而AVL是严格平衡树，因此在增加或者删除节点的时候，根据不同情况，旋转的次数比红黑树要多。

### HashMap初始化可以指定的参数
initialCapacity：初始化容量，默认是16
loadFactor：装载因子，默认是0.75

### HashMap插入流程🐋
[参考](https://javadoop.com/post/hashmap)
- 第一次put时会触发resize()操作，初始化到默认的16容量
-  通过(n - 1) & hash获得数组下标，如果这个位置为null，则初始化一个node放在这里
- 如果数组该位置有数据， 首先，判断该位置的第一个数据和我们要插入的数据，key 是不是"相等"，如果是，取出这个节点
- 如果不相等且是红黑树的结点，调用红黑树的插入方法
- 最后是链表，如果没有找到相等的，在链表末尾插入结点，插入后节点数量有8个了就将链表转化为红黑树
- 如果找到key相等的结点，用新值覆盖旧值，并返回旧值
- 如果新插入的值导致容量大于阈值，扩容

### HashMap扩容
- 用新的数组大小初始化新的数组（为原来的两倍，阈值也扩大一倍）
- 开始遍历原数组，进行数据迁移
- 如果该数组位置上只有单个元素，简单迁移这个元素就可以了
- 如果是链表，需要将此链表拆成两个链表，放到新的数组中，并且保留原来的先后顺序
- 用loHead、loTail 对应一条链表，hiHead、hiTail 对应另一条链表

***
如果tab[i]没有结点，则新建头节点；
否则判断是头节点，或者在链表中找，或者在树中找，如果是链表，就插入一个新节点，并判断是否要树化；
如果key存在，则修改value；

### HashMap扩容和缩容
数组的容量是以2的幂次方扩容的，那么一个Entity在扩容时，新的位置要么在**原位置**，要么在**原长度+原位置**的位置。因此，在扩容时，不需要重新计算元素的hash了，只需要判断最高位是1还是0就好了。

### HashMap为什么线程不安全？
JDK1.7 中，多线程对HashMap进行扩容。某个线程执行过程中，被挂起，当其他线程已经完成数据迁移，由于是头插法，等CPU资源释放后被挂起的线程重新执行之前的逻辑，数据已经被改变，造成死循环、数据丢失。

JDK1.8 中，多线程对HashMap进行put操作。假设两个线程A、B都在进行put操作，并且**hash函数计算出的插入下标是相同**的，当线程A执行完判断是否发生哈希碰撞后后由于时间片耗尽导致被挂起，而线程B得到时间片后在该下标处插入了元素，完成了正常的插入，然后线程A获得时间片，由于之前已经进行了hash碰撞的判断，所有此时不会再进行判断，而是直接进行插入，这就导致了线程B插入的数据被线程A覆盖了，从而线程不安全。

### ConcurrentHashMap插入元素
- 如果数组"空"，进行数组初始化
- 找到hash 值对应的数组下标，得到第一个节点f。如果数组该位置为空，用一次 CAS 操作将这个新值放入其中即可。
- 如果不为空，则在f上用synchronized
- 遍历链表，判断是否要进行值覆盖
- 到了链表的最末端，将这个新值放到链表的最后面
- 如果f是红黑树类型，调用红黑树的插值方法插入新节点
- 判断是否要将链表转换为红黑树，当前数组的长度大于 64且链表元素8或以上

初始化：
- 初始化方法中的并发问题是通过对 sizeCtl 进行一个 CAS 操作来控制的。
- 将 sizeCtl 设置为 -1，代表抢到了锁
- 将sizeCtl = sc;

扩容tryPresize方法：
- c：size 的 1.5 倍，再加 1，再往上取最近的 2 的 n 次方。

### HashTable、Collections.SynchronizedMap、ConcurrentHashMap🌟🌟

Hashtable 和 Collections.synchronizedMap() 方法返回的 SynchronizedMap 都是通过锁住整个对象实例的方法确保线程安全的。

ConcurrentHashMap 在不发生哈希冲突的情况下尽可能使用 CAS 确保线程安全，在发生哈希冲突情况下采用 synchronized 同步代码块方法锁住当前 Node 结点（只锁当前数组下标的 Node，其余结点不受影响）

Hashtable 的数据结构是数组加链表

[面试必备：HashMap、Hashtable、ConcurrentHashMap的原理与区别](https://www.cnblogs.com/heyonggang/p/9112731.html)

### HashMap 和 HashTable 区别
[参考](https://juejin.cn/post/6844903925460500487)
- Hashtable是线程安全，HashMap是非线程安全。
- HashMap可以使用null作为key。HashMap以null作为key时，总是存储在table数组的第一个节点上。而Hashtable则不允许null作为key。
- HashMap继承了AbstractMap，HashTable继承Dictionary抽象类，两者均实现Map接口。
- HashMap的初始容量为16，Hashtable初始容量为11，两者的填充因子默认都是0.75。HashMap扩容时是当前容量翻倍即:capacity 2，Hashtable扩容时是容量翻倍+1即:capacity (2+1)。
- HashMap和Hashtable的底层实现都是数组+链表结构实现。
- Hashtable计算hash是直接使用key的hashcode对table数组的长度直接进行取模；HashMap计算hash对key的hashcode进行了二次hash，以获得更好的散列值，然后对table数组长度取模。

### ConcurrentHashMap为什么是线程安全的？🌟
[参考](https://segmentfault.com/a/1190000041329741)
jdk1.7中ConcurrentHashMap是由一个Segment数组和多个HashEntry数组组成。Segment 本身是基于 ReentrantLock 实现的加锁和释放锁的操作，这样就能保证多个线程同时访问 ConcurrentHashMap 时，同一时间只有一个线程能操作相应的节点，这样就保证了 ConcurrentHashMap 的线程安全。

jdk1.8中ConcurrentHashMap是数组+链表，或者数组+红黑树结构。在 JDK 1.8 中，添加元素时首先会判断容器是否为空，如果为空则使用 volatile 加 CAS 来初始化。如果容器不为空则根据存储的元素计算该位置是否为空，如果为空则利用 CAS 设置该节点；如果不为空则使用 synchronize 加锁，遍历桶中的数据，替换或新增节点到桶中，最后再判断是否需要转为红黑树，这样就能保证并发访问时的线程安全了。

### ConcurrentHashMap底层原理

### HashMap与HashTable的区别🐋
[参考](https://juejin.cn/post/6844903925460500487)
- Hashtable是线程安全，HashMap是非线程安全。HashMap的性能会高于Hashtable。
- HashMap可以使用null作为key，以null作为key时，总是存储在table数组的第一个节点上。而Hashtable则不允许null作为key。
- HashMap继承了AbstractMap，HashTable继承Dictionary抽象类，两者均实现Map接口
- HashMap的初始容量为16，Hashtable初始容量为11，两者的填充因子默认都是0.75。HashMap扩容时是当前容量翻倍即:capacity * 2，Hashtable扩容时是容量翻倍+1即:capacity * 2+1
- Hashtable计算hash是直接使用key的hashcode对table数组的长度直接进行取模，HashMap计算hash对key的hashcode进行了二次hash，以获得更好的散列值，然后对table数组长度取模。

### 为什么负载因子是0.75
在理想情况下，使用随机哈希码，在扩容阈值（加载因子）为0.75的情况下，节点出现在频率在Hash桶（表）中遵循参数平均为0.5的泊松分布。

常数0.5是作为参数代入泊松分布来计算的，而加载因子0.75是作为一个条件，当HashMap长度为length/size ≥ 0.75时就扩容，正常情况下，链表个数出现 8 的概念不到千万分之一。

对于开放定址法，加载因子是特别重要因素，应严格限制在0.7-0.8以下。超过0.8，查表时的CPU缓存不命中（cache missing）按照指数曲线上升。

### Map集合中put与putIfAbsent的区别🐨
1. 使用put方法添加键值对，如果map集合中没有该key对应的值，则直接添加，并返回null，如果已经存在对应的值，则会覆盖旧值，value为新的值。
2. 使用putIfAbsent方法添加键值对，如果map集合中没有该key对应的值，则直接添加，并返回null，如果已经存在对应的值，则依旧为原来的值。

### 有哪些线程安全的集合类，讲一讲原理
-   CopyOnWriteArrayList：写入时复制，读取时固定，写入时避免覆盖造成数据问题。（当我们往一个容器添加元素的时候，不直接往当前容器添加，而是先将当前容器进行Copy，复制出一个新的容器，然后新的容器里添加元素，添加完元素之后，再将原容器的引用指向新的容器）
- CopyOnWriteArraySet
- HashSet：底层使用了HashMap中的Key。
- ConcurrentHashMap：采用CAS+synchronized来保证并发安全性，且synchronized关键字不是用在方法上而是用在了具体的对象上，实现了更小粒度的锁。ConcurrentHashMap采用数组+链表+红黑树，当链表长度超过某一个值，则将链表转成红黑树，提高查询效率。
- Hashtable：采用对象锁(synchronized修饰对象方法)来保证线程安全，Hashtable采用的是数组+链表，当链表过长会影响查询效率。
- Callable接口

### 集合类的顶级接口
java.until.Collection接口，所有集合的顶级接口，里面规定了集合所必须具备的相关功能

### ArrayList和LinkedList区别🐋🌟🌟
[逼着面试官问了我ArrayList和LinkedList的区别，他对我彻底服了](https://cloud.tencent.com/developer/news/700913)

**ArrayList**
ArrayList 实现了List接口，继承了AbstractList抽象类，底层是基于数组实现的，并且实现了动态扩容。

实现了 **RandomAccess 接口**，支持快速随机访问（不需要遍历，就可以通过下标（索引）直接访问）

ArrayList 还实现了 **Serializable 接口**，标记“实现了这个接口的类支持序列化”。Java 的序列化是指，将对象转换成以字节序列的形式来表示，这些字节序中包含了对象的字段和方法。序列化后的对象可以被写到数据库、写到文件，也可用于网络传输。

一旦在添加元素的时候，发现容量用满了 s == elementData.length，就按照原来数组的 1.5 倍（oldCapacity + oldCapacity >> 1）进行扩容。扩容之后，再将原有的数组复制到新分配的内存地址上 Arrays.copyOf(elementData, newCapacity)。

如果把整个数组都序列化的话，闲置的空间就非常大。它使用了 ArrayList 的实际大小 size 而不是数组的长度（elementData.length）来作为元素的上限进行序列化。

**LinkedList**
LinkedList 是一个继承自 AbstractSequentialList 的双向链表，因此它也可以被当作堆栈、队列或双端队列进行操作。

LinkedList 内部定义了一个 Node 节点，它包含 3 个部分：元素内容 item，前引用 prev 和后引用 next。

LinkedList 在序列化的时候只保留了元素的内容 item，并没有保留元素的前后引用。

遍历 LinkedList 的时候，千万不要使用 for 循环，要使用迭代器。

**区别**
1. ArrayList 实现了List接口，继承了AbstractList抽象类，底层是基于数组实现的，并且实现了动态扩容。LinkedList 是一个继承自 AbstractSequentialList 的双向链表，因此它也可以被当作堆栈、队列或双端队列进行操作。
2. 对于随机访问，ArrayList优于LinkedList，ArrayList实现了**RandomAccess 接口**，可以根据下标以O(1)时间复杂度对元素进行随机访问。而LinkedList的每一个元素都依靠地址指针和它后一个元素连接在一起，在这种情况下，查找某个元素的时间复杂度是O(n)
3. LinkedList 在删除比较靠前和比较靠后的元素时，非常高效，但如果删除的是中间位置的元素，效率就比较低了。ArrayList删除头部花费时间较多。
	1. 如果是从集合的尾部新增元素，ArrayList 花费的时间应该比 LinkedList 少，因为数组是一段连续的内存空间，也不需要复制数组；而链表需要创建新的对象，前后引用也要重新排列。
	2. ArrayList 在添加元素的时候如果不涉及到扩容，性能在两种情况下（中间位置新增元素、尾部新增元素）比 LinkedList 好很多，只有头部新增元素的时候比 LinkedList 差，因为数组复制的原因。

### ArrayList扩容过程🐨🌟
[参考](https://juejin.cn/post/6844903777544175623)
底层其实是调用了Arrays.copyOf方法来进行扩充数组容量的。

默认情况下，新的容量会是原容量的1.5倍，这里用了位运算提高效率。一般情况下，如果扩容1.5倍后就大于期望容量，那就返回这个1.5倍旧容量的值。而如果小于期望容量，那就返回期望容量。这里对默认容量10做了特殊处理。

使用1.5倍这个数值而不是直接使用期望容量，是为了防止频繁扩容影响性能。试想如果每次add操作都要扩容一次，那性能将会非常低下。

```java
// 设置新容量为旧容量的1.5倍
int newCapacity = oldCapacity + (oldCapacity >> 1); 
```

### 非线程安全的集合怎么改为线程安全?🌟
使用java.util.concurrent包提供的线程安全的并发集合可以大大简化多线程编程：

![](https://github.com/qingzhu0214/JavaPage/raw/wuzu/_posts/image/xcaq.png)

### List线程安全
Vector集合的所有操作元素的方法都加了synchronized关键字，这就导致了操作Vector的效率会非常低，在开发中，往往读操作的使用频率会远高于其他操作，而CopyOnWriteArrayList 就是这样一种读操作效率远高于写操作效率的List。

CopyOnWriteArrayList 底层是也是有数组实现的。 本文我们只解读添加元素和读取元素的区别，删除修改元素原理和添加元素差不多，操作时都需要进行加锁，而读操作不会加锁。

Vector和CopyOnWriteArrayList都是线程安全的List，底层都是数组实现的，Vector的每个方法都进行了加锁，而CopyOnWriteArrayList的读操作是不加锁的，因此CopyOnWriteArrayList的读性能远高于Vector，Vector每次扩容的大小都是原来数组大小的2倍，而CopyOnWriteArrayList不需要扩容，通过COW思想就能使数组容量满足要求。

**CopyOnWriteArrayLis的缺点：**
- 因为CopyOnWrite的写时复制机制，所以在进行写操作的时候，内存里会同时驻扎两个对象的内存，旧的对象和新写入的对象。如果这些对象占用的内存比较大，比如说200M左右，那么再写入100M数据进去，内存就会占用300M，那么这个时候很有可能造成频繁的Yong GC和Full GC。

- CopyOnWrite容器只能保证数据的最终一致性，不能保证数据的实时一致性。所以如果你希望写入的的数据，马上能读到，请不要使用CopyOnWrite容器。

### ArrayList，LinkedList对应的线程安全类
[参考](https://blog.csdn.net/qq_32907195/article/details/111562232)
方法1： Collections.synchronizedList(new LinkedList\<String>())
方法2:    LinkedList和ArrayList换成线程安全的集合，如CopyOnWriteArrayList，ConcurrentLinkedQueue......
方法3：Vector(内部主要使用synchronized关键字实现同步)

### 实现String.equals()
先比较地址值是否相等，在比较字符串的长度是否相等，最后对每个字符做一一对应比较。

1. 判断引用值是否相等，相等即返回rue，不用往下走；
2. 判断类型是否匹配，类型相同，长度相等，逐个比较字符是否一样，完全符合，则返回ture，一旦不对，返回false；
3. 类型不匹配，返回false

### TreeMap的使用场景，底层数据结构，红黑树的存取复杂度
TreeMap 实现了 SortMap 接口，其能够根据键排序，默认是按键的升序排序，也可以指定排序的比较器。当用 Iterator 遍历 TreeMap 时得到的记录是排过序的，TreeMap 取出来的是排序后的键值。

TreeMap 基于红黑树实现。

Treemap 红黑树中一个节点对应一个kv对，没有冗余无效的Node节点。而HashMap 的数组中，可能存在较多的空位。

TreeMap 的查询时间复杂度为 O(logN), 而HashMap为 O(1)，所以Map的元素越多，TreeMap根据key查询的效率会更低；

TreeMap 每次新增or删除一个kv对，都可能导致红黑树的重排；HashMap 当新增一个kv对，使得Map中的个数大于阀值时，需要对数组进行重新扩容。

对Map中的kv对有排序需求时，选择 TreeMap, 这种场景下，尽量保证以下几点：
- Map 元素基本保持不变（即很少添加和删除）
- 主要用于遍历迭代获取数据
- 不存在碰撞的情况（即两个不同的key，根据比较器获取值不能为0）

### TreeSet原理
TreeSet其实底层是通过TreeMap实现的。TreeSet的作用是保存无重复的数据，不过还对这些数据进行了排序。TreeMap的底层是通过红黑树实现的，所以TreeSet底层也是通过红黑树实现的。TreeSet最主要的特点就是对元素进行了排序。

**为什么value使用object作为值？**
```java
//add方法其实就是Map的put方法
public boolean add(E e) {
    return m.put(e, PRESENT)==null;
}
//remove方法其实就是Map的remove方法
public boolean remove(Object o) {
    return m.remove(o)==PRESENT;
}
```
元素e重复，m.put(e, PRESENT)一看e这个key已经存在了，就会将PRESENT替换掉相应的value值。然后map返回这个value。value不等于null，于是返回false。很明显插入失败了。

### Comparable接口和Comparator接口的区别
Comparable接口实现在自身类中，代表默认排序，相当于内部比较器；
而Comparator接口则是为类外实现的一个比较器，相当于外部比较器。
```java
public class Student implements Comparable<Student> {
    @Override
    public int compareTo(Student o) {
        return this.getGrade() > o.getGrade() ? 1 : this.getGrade() < o.getGrade() ? -1 : this.getName().compareTo(o.getName());
    }
}

Collections.sort(arr);
```

```java
public class StuCompartor implements Comparator<Student> {
    @Override
    public int compare(Student o1, Student o2) {
        return o1.getGrade() > o2.getGrade() ? 1 : o1.getGrade() < o2.getGrade() ? -1 : o1.getName().compareTo(o2.getName());
    }
}

Collections.sort(arr, new StuCompartor());//外部比较器
```

### LinkedHashMap的使用场景
[java集合类之LinkedHashMap](https://zhuanlan.zhihu.com/p/267377210)

HashMap有一个问题，就是迭代HashMap的顺序并不是HashMap放置的顺序，也就是无序。

根据插入顺序排序，此外，LinkedHashMap还有一个参数决定是否在此基础上再根据访问顺序(get,put)排序，记住，是在插入顺序的基础上再排序。

例如，我们构建一个空间占用敏感的资源池，希望可以自动将最不常被访问的对象释放掉，这就可以利用 LinkedHashMap 提供的机制来实现。

LinkedHashMap的数据存储和HashMap的结构一样采用(数组+单向链表)的形式，只是在每次节点Entry中增加了用于维护顺序的before和after变量维护了一个双向链表来保存LinkedHashMap的存储顺序。

当我们开启accessOrder为true时，最新访问(get或者put(更新操作))的数据会被丢到队列的尾巴处，那么双向队列的头就是最不经常使用的数据了。

removeEldestEntry(Map.Entry<K,V> eldest) 方法。该方法可以提供在每次添加新条目时移除最旧条目的实现程序，默认返回 false。

### [LinkedList 那种场景比 ArrayList 更好？](https://xie.infoq.cn/article/d9955e0d2657f6481a8c9b448)
- 从集合中间位置位置添加元素LinkedList快很多。
- 从集合尾部位置添加元素：在没有扩容的情况下，ArrayList 的效率要高于 LinkedList。
- 从集合中间位置位置添加元素：LinkedList 将元素添加到中间位置，是添加元素最低效率的，因为靠近中间位置，在添加元素之前的循环查找是遍历元素最多的操作。

ArrayList 和 LinkedList 删除元素操作测试的结果和添加元素操作测试的结果很接近！
如果需要在 List 的**头部进行大量的插入、删除操作**，那么直接选择 LinkedList。否则，ArrayList 即可。

### Java常用的集合类
List、Set、Map

### 能排序的set实现原理
TreeSet底层是TreeMap来实现的。底层基于红黑树实现。

和 HashSet 不同的是，TreeSet 中的元素不需要重写 hashCode() 和 equals() 方法，因为 TreeSet 是通过比较器去重的，所有元素都必须实现 Comparable 接口，然后重写 compareTo() 方法。

### HashMap为什么线程不安全
[面试官： HashMap 为什么线程不安全？](https://juejin.cn/post/6844904149616705543)
1.  在 jdk1.7 中，在多线程环境下，扩容时会造成环形链或数据丢失。 
2.  在 jdk1.8 中，在多线程环境下，会发生数据覆盖的情况。

### 讲讲 ConcurrentHashMap ？
HashMap是线程不安全的，目前主要用的ConcurrentHashMap来保证线程安全性。
![](https://github.com/qingzhu0214/JavaPage/raw/wuzu/_posts/image/ConcurrentHashMap.png)

一个 Segment里包含一个 HashEntry 数组，每个 HashEntry 是一个链表结构的元素， 每个 Segment守护者一个 HashEntry 数组里的元素，当对 HashEntry数组的数据进行修改时，必须首先获得它对应的 Segment 锁。

内部使用段(Segment)来表示这些不同的部分，每个段其实就是一个小的HashTable，只要多个修改操作发生在不同的段上，它们就可以并发进行。

用于存储键值对数据的HashEntry，在设计上它的成员变量value跟next都是volatile类型的，这样就保证别的线程对value值的修改，get方法可以马上看到。

>先通过hash值找segment的位置，再通过另一个hash值找在map里的位置

**JDK1.8相比JDK1.7：**
1. 取消了segment数组，直接用table保存数据，锁的粒度更小，减少并发冲突的概率。采用table数组元素作为锁，从而实现了对每一行数据进行加锁，进一步减少并发冲突的概率，并发控制使用Synchronized和CAS来操作。【concurrentHashMap内部使用sychronized + volatile + CAS 的实现降低锁的粒度，大家可以认为粒度就是HashEntry（首节点）】
2. 存储数据时采用了数组+ 链表+红黑树的形式。

### 介绍下自旋锁和互斥锁，可重入锁和不可重入锁，公平锁和非公平锁的区别🌟
[不可不说的Java“锁”事](https://tech.meituan.com/2018/11/15/java-lock.html)
公平锁是指多个线程按照申请锁的顺序来获取锁。
非公平锁是指多个线程获取锁的顺序并不是按照申请锁的顺序，有可能后申请的线程比先申请的线程优先获取锁。有可能，会造成优先级反转或者饥饿现象。

可重入锁：可重入锁指的是在一个线程中可以多次获取同一把锁，比如：**一个线程在执行一个带锁的方法，该方法中又调用了另一个需要相同锁的方法，则该线程可以直接执行调用的方法，而无需重新获得锁**；【一个线程中的多个流程能不能获取同一把锁】
不可重入锁：当前线程执行某个方法已经获取了该锁，那么在方法中尝试再次获取锁时，就会获取不到被阻塞。

互斥锁：用于保护临界区，确保同一时间只有一个线程访问数据。对共享资源的访问，先对互斥量进行加锁，如果互斥量已经上锁，调用线程会阻塞，直到互斥量被解锁。
自旋锁与互斥锁有点类似，只是自旋锁不会引起调用者睡眠，如果自旋锁已经被别的执行单元保持，调用者就一直循环在那里看是否该自旋锁的保持者已经释放了锁。
当加锁失败时，互斥锁用「线程切换」来应对，自旋锁则用「忙等待」来应对。

### 为什么公平锁要比非公平锁慢？🐨
**公平锁**
获取锁时，先将线程自己添加到等待队列的队尾并休眠，当某线程用完锁之后，会去唤醒等待队列中队首的线程尝试去获取锁，锁的使用顺序也就是队列中的先后顺序，在整个过程中，线程会从运行状态切换到休眠状态，再从休眠状态恢复成运行状态，但线程每次休眠和恢复都需要从用户态转换成内核态，而这个状态的转换是比较慢的，所以公平锁的执行速度会比较慢。

**非公平锁**
当线程获取锁时，会先通过 CAS 尝试获取锁，如果获取成功就直接拥有锁，如果获取锁失败才会进入等待队列，等待下次尝试获取锁。这样做的好处是，获取锁不用遵循先到先得的规则，从而避免了线程休眠和恢复的操作，这样就加速了程序的执行效率。

公平锁要维护一个队列，后来的线程要加锁，即使锁空闲，也要先检查有没有其他线程在 wait，如果有自己要挂起，加到队列后面，然后唤醒队列最前面的线程。这种情况下相比较非公平锁多了一次挂起和唤醒。
线程切换的开销，其实就是非公平锁效率高于公平锁的原因，因为非公平锁减少了线程挂起的几率，后来的线程有一定几率逃离被挂起的开销。

### Java对象中对象头有哪些内容？🐋
由 Mark Word、Class Pointer、数组长度三个字段组成。
- Mark Word：主要用于存储自身运行时数据
- Class Pointer：是指针，指向方法区中该 class 的对象，JVM 通过此字段来判断当前对象是哪个类的实例
- 数组长度：当且仅当对象是数组时才会有该字段

![](https://github.com/qingzhu0214/JavaPage/raw/wuzu/_posts/image/suo.png)

### Java的对象头mark word
[参考](https://juejin.cn/post/6978882583492821023)
mark word主要用来表示对象的线程锁状态，另外还可以用来配合GC、以及存放该对象的hashCode

- 在正常不加锁时，mark word 由lock、biased_lock、age、identity_hashcode组成，age是GC的年龄，最大15（4位），每从Survivor区复制一次，年龄增加1。identity_hashcode就是对象的哈希码，当对象处于加锁状态时，这个哈希码会移到monitor，（synchronized会在代码块前后插入monitor）。

- 在偏向锁时，mark word 由lock、biased_lock、age、epoch、thread组成。epoch：偏向锁在CAS锁操作过程中，偏向性标识，表示对象更偏向哪个锁。thread：持有偏向锁的线程ID，如果该线程再次访问这个锁的代码块，可以直接访问。

- 在轻量级锁时，mark word 由lock、ptr_to_lock_record组成。ptr_to_lock_record：指向栈中锁记录的指针。

- 在重量级锁时，mark word 由lock、ptr_to_heavyweight_monitor组成。ptr_to_heavyweight_monitor：指向对象监视器Monitor的指针。

### 锁升级🐋🌟🌟
锁的状态总共有四种，级别由低到高依次为：无锁、偏向锁、轻量级锁、重量级锁，锁状态只能升级，不能降级。

锁竞争：如果多个线程轮流获取一个锁，但是每次获取锁的时候都很顺利，没有发生阻塞，那么就不存在锁竞争。只有当某线程尝试获取锁的时候，发现该锁已经被占用，只能等待其释放，这才发生了锁竞争。

[参考](https://tech.meituan.com/2018/11/15/java-lock.html)
无锁：
修改操作在循环内进行，线程会不断的尝试修改共享资源。如果没有冲突就修改成功并退出，否则就会继续循环尝试。**如果有多个线程修改同一个值，必定会有一个线程能修改成功，而其他修改失败的线程会不断重试直到修改成功。** CAS就是一种无锁的实现。

偏向锁：
**一段同步代码一直被一个线程所访问，那么该线程会自动获取锁，降低获取锁的代价。**
当一个线程访问同步代码块并获取锁时，会在Mark Word里存储锁偏向的线程ID。在线程进入和退出同步块时不再通过CAS操作来加锁和解锁，而是检测Mark Word里是否存储着指向当前线程的偏向锁。
轻量级锁的获取及释放依赖多次CAS原子指令，而偏向锁只需要在置换ThreadID的时候依赖一次CAS原子指令即可。

轻量级锁：
**一旦有第二个线程参与竞争，就会立即膨胀为轻量级锁。** 企图抢占的线程一开始会使用自旋的方式去尝试获取锁。如果循环几次，其他的线程释放了锁，就不需要进行用户态到内核态的切换。

重量级锁：
**试图抢占的线程自旋达到阈值，就会停止自旋，那么此时锁就会膨胀成重量级锁。** 当其膨胀成重量级锁后，其他竞争的线程进来就不会自旋了，而是直接阻塞等待，并且 Mark Word 中的内容会变成一个监视器（monitor）对象，用来统一管理排队的线程。

偏向锁通过对比Mark Word解决加锁问题，避免执行CAS操作。而轻量级锁是通过用CAS操作和自旋来解决加锁问题，避免线程阻塞和唤醒而影响性能。重量级锁是将除了拥有锁的线程以外的线程都阻塞。

### 多线程环境下为什么要引入同步的机制
不同的线程有自己的栈，栈中可能引用了多个对象，而多个线程可能引用到了堆中的同一个或多个对象，而线程的栈内存当中的数据只是临时数据，最终都是要刷新到堆中的对象内存。当多个线程对同一个对象中的同一个变量进行读写的时候，就会出现类似数据库中的并发问题。

### synchronized和ReenreantLock有什么区别🐋🐋🐋🌟🌟🌟🌟🌟
相同点：
1. 都是可重入锁
2. 都保证了可见性和互斥性
3. 都可以用于控制多线程对共享对象的访问

不同点：
1. ReentrantLock等待可中断
2. synchronized中的锁是非公平的，ReentrantLock默认也是非公平的，但是可以通过修改参数来实现公平锁
3. ReentrantLock可以绑定多个条件
4. synchronized是Java中的关键字是JVM级别的锁，而ReentrantLock是一个Lock接口下的实现类，是API层面的锁
5. synchronized隐式获取锁和释放锁，ReentrantLock显示获取和释放锁，在使用时避免程序异常无法释放锁，需要在finally控制块中进行解锁操作
***
**深入理解Java虚拟机上的答案**
ReentrantLock与synchronized相比增加了一些高级功能，主要有以下三项：**等待可中断、可实现公平锁及锁可以绑定多个条件**。
1. 等待可中断：是指当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情。可中断特性对处理执行时间非常长的同步块很有帮助。
2. 公平锁：是指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁；而非公平锁则不保证这一点，在锁被释放时，任何一个等待锁的线程都有机会获得锁。synchronized中的锁是非公平的，ReentrantLock 在默认情况下也是非公平的，但可以通过带布尔值的构造函数要求使用公平锁。不过一旦使用了公平锁，将会导致 ReentrantLock 的性能急剧下降，会明显影响吞吐量。
3. 锁绑定多个条件：是指一个ReentrantLock对象可以同时绑定多个Condition对象。在synchronized中，锁对象的wait()跟它的notify()或者notifyAll()方法配合可以实现一个隐含的条件，如果要和多于一个的条件关联的时候，就不得不额外添加一个锁；而ReentrantLock则无须这样做，多次调用newCondition()方法即可。
4. synchronized是在Java语法层面的同步，足够清晰，也足够简单。
5. Lock应该确保在finally块中释放锁，否则一旦受同步保护的代码块中抛出异常，则有可能永远不会释放持有的锁。这一点必须由程序员自己来保证，而使用synchronized的话则可以由Java虚拟机来确保即使出现异常，锁也能被自动释放。
***
[synchronized和ReenreantLock有什么区别](https://segmentfault.com/a/1190000039091031)
[参考](https://blog.csdn.net/weixin_39309402/article/details/106428452)

Synchronized可以修饰实例方法，静态方法，代码块。自动释放锁。
ReentrantLock一般需要try catch finally语句，在try中获取锁，在finally释放锁。需要手动释放锁。

Synchronized是重量级锁。重量级锁需要将线程从内核态和用户态来回切换。如：A线程切换到B线程，A线程需要保存当前现场，B线程切换也需要保存现场。这样做的缺点是耗费系统资源。
ReentrantLock是轻量级锁。**采用cas+volatile管理线程**，不需要线程切换切换，获取锁线程觉得自己肯定能成功，这是一种**乐观的思想**（可能失败）。

Synchronized只有非公平锁。
ReentrantLock提供公平和非公平两种锁，默认是非公平的。公平锁通过构造函数传递true表示。

Synchronized和ReentrantLock都是可重入的，Synchronized是本地方法是C++实现，而ReentrantLock是JUC包用Java实现。

Synchronized是不可中断的。
ReentrantLock提供可中断和不可中断两种方式。其中lockInterruptibly方法表示可中断，lock方法表示不可中断。

Synchronized只有一个等待队列。
ReentrantLock中一把锁可以对应多个条件队列。通过newCondition表示。

可见Lock对象锁还提供了synchronized所不具备的其他同步特性，如可中断锁的获取(synchronized在等待获取锁时是不可中断的)，超时中断锁的获取，等待唤醒机制的多条件变量Condition等，这也使得Lock锁在使用上具有更大的灵活性。

### 实现Lock接口的类有什么？
ReentrantLock
ReentrantReadWriteLock：高16位为读状态的数量，低16位为写状态的数量

### synchronized底层原理
[参考](https://blog.csdn.net/javazejian/article/details/72828483)
monitor对象存在于每个Java对象的对象头中。monitor是由ObjectMonitor实现的，_ owner指向持有ObjectMonitor对象的线程，当多个线程同时访问一段同步代码时，首先会进入 _ EntryList 集合，当线程获取到对象的monitor 后进入 _ Owner 区域并把monitor中的owner变量设置为当前线程同时monitor中的计数器count加1，若线程调用 wait() 方法，将释放当前持有的monitor，owner变量恢复为null，count自减1，同时该线程进入 WaitSe t集合中等待被唤醒。若当前线程执行完毕也将释放monitor(锁)并复位变量的值，以便其他线程进入获取monitor(锁)。

JVM可以从方法常量池中的方法表结构(method_info Structure) 中的 ACC_SYNCHRONIZED 访问标志区分一个方法是否同步方法。当方法调用时，调用指令将会 检查方法的 ACC_SYNCHRONIZED 访问标志是否被设置，如果设置了，执行线程将先持有monitor， 然后再执行方法，最后再方法完成时释放monitor。在方法执行期间，执行线程持有了monitor，其他任何线程都无法再获得同一个monitor。如果一个同步方法执行期间抛 出了异常，并且在方法内部无法处理此异常，那这个同步方法所持有的monitor将在异常抛到同步方法之外时自动释放。

***
synchronized的对象锁，锁标识位为10，其中指针指向的是monitor对象。但当一个 monitor 被某个线程持有后，它便处于锁定状态。在Java虚拟机(HotSpot)中，monitor是由ObjectMonitor实现。

ObjectMonitor中有两个队列，_ WaitSet 和 _ EntryList，用来保存ObjectWaiter对象列表。_ owner指向持有ObjectMonitor对象的线程。

**同步语句块**的实现使用的是monitorenter 和 monitorexit 指令，当执行monitorenter指令时，当前线程将试图获取 objectref(即对象锁) 所对应的 monitor 的持有权，当 objectref 的 monitor 的进入计数器为 0，那线程可以成功取得 monitor，并将计数器值设置为 1，取锁成功。

**方法级**的同步是隐式，即无需通过字节码指令来控制的，它实现在方法调用和返回操作之中。JVM可以从方法常量池中的方法表结构(method_info Structure) 中的 ACC_SYNCHRONIZED 访问标志区分一个方法是否同步方法。

### reentrantlock 底层原理
[参考](https://www.jianshu.com/p/0e4bad774cc5)
ReentrantLock主要利用CAS+AQS队列来实现。在Java中，CAS主要是由sun.misc.Unsafe这个类通过JNI调用CPU底层指令实现。

先通过CAS尝试获取锁。如果此时已经有线程占据了锁，那就加入AQS队列并且被挂起。当锁被释放之后，排在CLH队列队首的线程会被唤醒，然后CAS再次尝试获取锁。在这个时候，如果：
非公平锁：如果同时还有另一个线程进来尝试获取，那么有可能会让这个线程抢先获取；
公平锁：如果同时还有另一个线程进来尝试获取，当它发现自己不是在队首的话，就会排到队尾，由队首的线程获取到锁。

### AQS的理解🐋
AQS（AbstractQueuedSynchronizer，抽象队列同步器）是Java中重入锁ReentrantLock、读写锁、信号量的实现基础。

### AbstractQueuedSynchronizer
https://javadoop.com/post/AbstractQueuedSynchronizer
https://tech.meituan.com/2019/12/05/aqs-theory-and-apply.html
AbstractQueuedSynchronizer会把请求获取锁失败的线程放入一个队列的尾部：等待获取锁的线程全部处于阻塞状态。当前线程执行完毕（释放锁）后，会激活当前线程的后继节点。
ReentranLock公平锁会让最先进入队列的线程获得锁。
ReentranLock非公平锁则会让当前正在请求的线程插队获取锁，获取失败则放在队尾排队等待。

***
[参考](https://javadoop.com/post/AbstractQueuedSynchronizer)
Node 的数据结构包含 thread 、 waitStatus 、 pre 、 next 四个属性。

**公平锁**：FairSync是ReentrantLock的内部类

加锁：
- ReentrantLock -> FairSync -> FairSync#lock -> AQS#acquire(1);
- acquire方法里先尝试tryAcquire， 如果tryAcquire(arg)没有成功，这个时候需要把当前线程挂起，放到阻塞队列中。
- tryAcquire成功【返回true】的情况有：没有线程在等待锁和重入锁，线程本来就持有锁。
- addWaiter方法把线程包装成node，同时进入到队列中
- 如果队列不为空且CAS将自己设置成队尾成功，直接返回
- 否则调用enq方法采用自旋的方式入队
- acquireQueued里先判断前置节点是否为head，是的话尝试获取锁，否则通过shouldParkAfterFailedAcquire方法判断是否需要挂起线程，如果前驱结点状态等于-1，说明当前结点需要挂起。如果前驱节点 waitStatus大于0，一直向前搜索找到waitStatus<=0的结点。如果前驱节点 waitStatus等于0，用CAS将前驱节点的waitStatus设置为Node.SIGNAL(也就是-1)。
- 挂起线程 `LockSupport.park(this);`

解锁：
ReentrantLock#unlock() -> Sync#release(1) -> AQS#release() -> ReentrantLock#tryRelease

- tryRelease方法判断是否是拥有锁的线程，不是则抛出异常
- 用当前state减去release的数量，等于0说明不持有锁了，释放掉锁
- 调用unparkSuccessor(head)方法
- 如果head节点当前waitStatus<0, 将其修改为0
- 唤醒后继节点，但是有可能后继节点取消了等待（waitStatus > 0），所以从队尾往前找，找到waitStatus<=0的所有节点中排在最前面的
- 唤醒后续线程 `LockSupport.unpark(s.thread);`

### Reentrantlock源码
[参考](https://tech.meituan.com/2019/12/05/aqs-theory-and-apply.html)
AQS使用一个Volatile的int类型的成员变量来表示同步状态，通过内置的FIFO队列来完成资源获取的排队工作，通过CAS完成对State值的修改。

加锁：
- 通过ReentrantLock的加锁方法Lock进行加锁操作。
- 会调用到内部类Sync的Lock方法，由于Sync#lock是抽象方法，根据ReentrantLock初始化选择的公平锁和非公平锁，执行相关内部类的Lock方法，本质上都会执行AQS的Acquire方法。
- AQS的Acquire方法会执行tryAcquire方法，但是由于tryAcquire需要自定义同步器实现，因此执行了ReentrantLock中的tryAcquire方法，由于ReentrantLock是通过公平锁和非公平锁内部类实现的tryAcquire方法，因此会根据锁类型不同，执行不同的tryAcquire。
- tryAcquire是获取锁逻辑，获取失败后，会执行框架AQS的后续逻辑，跟ReentrantLock自定义同步器无关。

解锁：
- 通过ReentrantLock的解锁方法Unlock进行解锁。
- Unlock会调用内部类Sync的Release方法，该方法继承于AQS。
- Release中会调用tryRelease方法，tryRelease需要自定义同步器实现，tryRelease只在ReentrantLock中的Sync实现，因此可以看出，释放锁的过程，并不区分是否为公平锁。
- 释放成功后，所有处理由AQS框架完成，与自定义同步器无关。

![](image/lock.png)

### 非公平和公平锁的区别
公平锁就是在获取锁之前会先判断**等待队列是否为空**或者自己**是否位于队列头部**，该条件通过才能继续获取锁。

```java
// 非公平
if (compareAndSetState(0, acquires)) {
	setExclusiveOwnerThread(current);
	return true;
}

// 公平，区别在于是否先判断等待队列是否为空或者自己是否位于队列头部
 if (!hasQueuedPredecessors() &&
	compareAndSetState(0, acquires)) {
	setExclusiveOwnerThread(current);
	return true;
}
```

非公平锁减少了线程挂起的几率。

非公平锁有两次CAS的情况，首先进入ReentrantLock的内部类NonfairSync#lock方法，如果CAS设置状态成功，就把线程自己改成拥有锁的线程。否则进入AQS#acquire方法，调用NonfairSync#nonfairTryAcquire方法，再次尝试CAS获取锁。如果都获取失败的话就把自己加入等待队列。

公平锁首先进入ReentrantLock的内部类FairSync#lock方法，直接调用AQS继承来的acquire方法，再进入FairSync#tryAcquire方法，判断hasQueuedPredecessors的返回值，就是说明前面是否有线程在排队，没有线程在排队才尝试去获取锁。如果获取失败的话就把自己加入等待队列。

### 公平锁和非公平锁
[参考](https://zhuanlan.zhihu.com/p/45305463)

公平锁：
首先tryAcquire一下，通过hasQueuedPredecessors方法判断队列有没有等待的线程。没有的话就通过CAS把自己设为锁的持有者。或者看当前线程是否已经拥有锁，【重入的情况】，是的话修改一下state的值。否则就将线程封装成节点，加入到队列末尾。

***
[参考](https://zhuanlan.zhihu.com/p/45305463)
lock -> acquire -> tryAcquire -> hasQueuedPredecessors
公平锁的tryAcquire方法里有个!hasQueuedPredecessors()条件，意思是说当前同步队列没有前驱节点（也就是没有线程在等待）时才会去compareAndSetState(0, acquires)使用CAS修改同步状态变量。

lock -> compareAndSetState -> 失败了才去 -> acquire

非公平锁的实现在刚进入lock方法时会直接使用一次CAS去尝试获取锁，不成功才会到acquire方法中。而在nonfairTryAcquire方法中并没有判断是否有前驱节点在等待，直接CAS尝试获取锁。由此实现了非公平锁。

### synchronized和volatile的区别🌟🌟
1. volatile只能作用于变量，而synchronized可以作用于变量、方法和代码块
2. 多线程访问volatile不会发生阻塞，而synchronized关键字可能发生阻塞。
3. volatile能够保证数据的可见性，就是在多个线程之间是可见的，不能保证原子性，而synchronized关键字都可以保证。
4. volatile关键字主要解决的是多个线程之间的可见性，而synchronized关键字保证的是多个线程访问资源的同步性。

### volatile应用场景
使用volatile必须具备以下2个条件：
- 对变量的写操作不依赖于当前值；
- 该变量没有包含在具有其他变量的不变式中。

下面列举两个使用场景：
- 状态标记量（本文中代码的列子）
- 双重检查（单例模式）

### 在static代码块上可以加synchronized吗？跟在类上添加有什么区别？
synchronized 包括三种用法：
1. 修饰实例方法：所谓的实例对象锁就是用 synchronized 修饰实例对象中的实例方法，注意是实例方法不包括静态方法。
2. 修饰静态方法：当 synchronized 作用于静态方法时，其锁就是当前类的 class 对象锁。由于静态成员不专属于任何一个实例对象，是类成员，因此通过 class 对象锁可以控制静态成员的并发操作。
3. 修饰代码块：包含成员锁（锁的是变量）、实例对象锁（this）、当前类的 class 对象锁

### Synchronized锁住成员变量和静态变量的区别
当synchronized修饰一个static方法时，多线程下，获取的是类锁（即Class本身，注意：不是实例）；
当synchronized修饰一个非static方法时，多线程下，获取的是对象锁（即类的实例对象）
当synchronized修饰一个static方法时，创建线程不管是new JoinThread()还是new Thread(new JoinThread())，在run方法中执行inc()方法都是同步的；

### [静态语句块的执行时机](https://dzone.com/articles/the-hidden-synchronized-keyword-with-a-static-bloc)
每当发生以下事件之一时，ClassLoader 都需要加载 Class：
- 静态成员变量由应用程序设置（应用程序是指包含静态块的类之外的代码）
- 应用程序访问非最终静态成员变量
- 应用程序调用静态方法
- Class.forName(“..”)
- 使用 Class.newInstance() 或通过 new 关键字创建实例

由于静态块的使用是在类的初始化/加载中（应该只发生一次），因此该块被 JVM 视为“同步”块。只有当类状态为“未初始化”时，线程才能访问此代码块。由于有多个上述事件可以触发类加载，JVM 需要确保类加载/初始化只发生一次。为了确保这一点，每个类都有一个“初始化锁”，它由首先到达静态块的线程获取，并且只有在静态块代码执行完成后才会释放锁。

在此之前，其他线程在任何活动上都会被阻塞，例如尝试加载类或创建实例。一旦锁被释放，类的状态被设置为“完全初始化”，不需要任何其他线程进入静态块。

### 说说Java对象的四种引用方式🐋
1. 强引用 StrongReference：StrongReference是Java的默认引用形式，使用时不需要显示定义。任何通过强引用所使用的对象不管系统资源有多紧张，Java GC都不会主动回收具有强引用的对象。
2. 弱引用 WeakReference：如果一个对象只具有弱引用，无论内存充足与否，Java GC后对象如果只有弱引用将会被自动回收。
3. 软引用 SoftReference：软引用和弱引用的特性基本一致， 主要的区别在于软引用在内存不足时才会被回收。如果一个对象只具有软引用，Java GC在内存充足的时候不会回收它，内存不足时才会被回收。【构建缓存的时候使用】
4. 虚引用 PhantomReference：它的get()方法无论何时返回的都只会是null。所以单独使用虚引用时，没有什么意义，需要和引用队列ReferenceQueue类联合使用。当执行Java GC时如果一个对象只有虚引用，就会把这个对象加入到与之关联的ReferenceQueue中。可用来在对象被回收时做额外的一些资源清理或事物回滚等处理。  

### Atomic原子类的原理🐨
Atomic 使用乐观策略，每次操作时都假设没有冲突发生，并采用 volatile 配合 CAS 去修改内存中的变量，如果失败则重试，直到成功为止。

### CAS原语的实现原理🌟
[参考](https://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&mid=2651749434&idx=3&sn=5ffa63ad47fe166f2f1a9f604ed10091&chksm=bd12a5778a652c61509d9e718ab086ff27ad8768586ea9b38c3dcf9e017a8e49bcae3df9bcc8&scene=38#wechat_redirect)
Compare-And-Swap：它的功能是判**断内存某个位置的值是否为预期值，如果是则更改为新的值**，这个过程是原子的。

JAVA中的CAS操作都是通过sun包下Unsafe类实现，而Unsafe类中的方法都是native方法，由JVM本地实现。

调用了“Atomic::cmpxchg”方法，CAS底层实现根据不同的操作系统会有不同重载。

核心代码就是一条**带lock 前缀**的 cmpxchg 指令，即lock cmpxchg dword ptr [edx], ecx。

指令操作的内存区域就会加锁，导致其他处理器不能同时访问它。

JDK通过CPU的cmpxchg指令，去比较寄存器中的 A 和 内存中的值 V。如果相等，就把要写入的新值 B 存入内存中。如果不相等，就将内存值 V 赋值给寄存器中的值 A。然后通过Java代码中的while循环再次调用cmpxchg指令进行重试，直到设置成功为止。

[CAS存在的问题](https://www.infoq.cn/article/atomic-operation)
[原子操作是如何实现的](https://zhuanlan.zhihu.com/p/33445834)

### CAS有哪些问题？🐨
**ABA问题：** 如果变量V初次读取的时候值是A，后来变成了B，然后又变成了A，你本来期望的值是第一个A才会设置新值，第二个A跟期望不符合，但却也能设置新值。

java并发包中提供了一个带有标记的原子引用类AtomicStampedReference，它可以通过控制变量值的版本号来保证CAS的正确性，比较两个值的引用是否一致，如果一致，才会设置新值。

**无限循环问题：** Atomic类设置值的时候会进入一个无限循环，只要不成功，就会不停的循环再次尝试。在高并发时，如果大量线程频繁修改同一个值，可能会导致大量线程执行compareAndSet()方法时需要循环N次才能设置成功，即大量线程执行一个重复的空循环（自旋），造成大量开销。

可以使用java8中的LongAdder，分段CAS和自动分段迁移。
当LongAdder不存在并发访问的时候，会直接通过cas的方式更新base的值，存在并发访问时，会定位到某一个cell，修改cell的value。如果需要求和，则将base和所有的cell加起来即可。

**多变量原子问题：** 只能保证一个共享变量的原子操作。一般的Atomic类，只能保证一个变量的原子性，但如果是多个变量呢？

可以用AtomicReference，这个是封装自定义对象的，多个变量可以放一个自定义对象里，然后他会检查这个对象的引用是不是同一个。如果多个线程同时对一个对象变量的引用进行赋值，用AtomicReference的CAS操作可以解决并发冲突问题。

### volatile 的原理🐋🌟🌟🌟
[参考](https://zhuanlan.zhihu.com/p/151289085)
**定义**
Java编程语言允许线程访问共享变量，为了确保共享变量能被准确和一致的更新，线程应该确保通过排它锁单独获得这个变量。Java语言提供了volatile，在某些情况下比锁更加方便。如果一个字段被声明成volatile，Java线程内存模型确保所有线程看到这个变量的值是一致的。

**volatile的第一个特性--保证可见性**
- 当一个变量被声明为volatile时，线程在写入变量时不会把值缓存在寄存器或者其他地方，而是会把值刷新回主内存。
- 当其他线程读取该共享变量时，会从主内存重新获取最新值，而不是使用当前线程的工作内存中的值。

**volatile的第二个特性--保证有序性**
为了实现volatile的内存语义，编译器在生成字节码时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序。

![](https://github.com/qingzhu0214/JavaPage/raw/wuzu/_posts/image/内存屏障.jpg)

volatile的底层是通过：store，load等内存屏障命令，解决JMM的可见性和重排序问题的。但是它无法解决竞争问题，要解决竞争问题需要加锁，或使用cas等无锁技术。

- 对于volatile的**写操作**，在其前后分别加上 StoreStore 和 StoreLoad指令
- 对于volatile的**读操作**，在其后加上 LoadLoad 和 LoadStore指令

### 讲讲 AtomicInteger 和 volatile 的原理，以及前者如何实现原子性的，二者的区别？🌟

volatile三大特性：保证可见性、不保证原子性、禁止指令重排
可见性：指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。

Java中的volatile关键字是通过调用C语言实现的，而在更底层的实现上，即汇编语言的层面上，用volatile关键字修饰后的变量在操作时，最终解析的汇编指令会在指令前加上**lock前缀**指令来保证工作内存中读取到的数据是**主内存中最新的数据**。
具体的实现原理是在硬件层面上通过：**MESI缓存一致性协议**：多个cpu从主内存读取数据到高速缓存中，如果其中一个cpu修改了数据，会通过总线立即回写到主内存中，其他cpu会通过总线嗅探机制感知到缓存中数据的变化并将工作内存中的数据失效，再去读取主内存中的数据。

AtomicInteger基于CAS实现。
-   Java中的CAS操作正是利用了处理器提供的CMPXCHG指令实现的。自旋CAS实现的基本思路就是循环进行CAS操作直到操作成功为止。
-   在CAS中有三个操作数：分别是内存地址（在Java中可以简单理解为变量的内存地址，用V表示）、旧的预期值（用A表示）和新值（用B表示）。CAS指令执行时，当且仅当V符合旧的预期值A时，处理器才会用新值B更新V的值，否则他就不执行更新，但无论是否更新了V的值，都会返回V的旧值。

### [String能存储的最大字符长度是多少？](https://www.cnblogs.com/54chensongxia/p/13640352.html)
String 的长度是有限制的。
-   编译期的限制：字符串的UTF8编码值的字节数不能超过65535，字符串的长度不能超过65534；
-   运行时限制：字符串的长度不能超过2^31-1，占用的内存数不能超过虚拟机能够提供的最大值。

### Java的static关键词
static方法就是没有this的方法。在static方法内部不能调用非静态方法，反过来是可以的。而且可以在没有创建任何对象的前提下，仅仅通过类本身来调用static方法。

1. static关键字修饰**类**：普通类是不允许声明为静态的，只有**内部类**才可以。如果没有用static修饰InterClass，则只能new 一个外部类实例。再通过外部实例创建内部类。
2. static关键字修饰**方法**：想在不创建对象的情况下调用某个方法，就可以将这个方法设置为static。
3. static关键字修饰**变量**：静态变量被所有的对象所共享，在内存中只有一个副本，它当且仅当在类初次加载时会被初始化。
4. static关键字修饰**代码块**：static块可以置于类中的任何地方，类中可以有多个static块。在类初次被加载的时候，会按照static块的顺序来执行每个static块，并且只会执行一次。（只会在类加载的时候执行一次）

静态变量存放在方法区中，并且是被所有线程所共享的。方法区是一个逻辑概念，其具体实现为jdk1.8的元空间与jdk1.8之前的永久代，他们之间最大的区别在于：元空间并不在JVM管理的内存中，而是使用本地内存。

### 静态内部类
即使没有外部类对象，也可以创建静态内部类对象，而外部类的非static成员必须依赖于对象的调用，静态成员则可以直接使用类调用，不必依赖于外部类的对象，所以静态内部类只能访问静态的外部属性和方法。

### Final关键字作用🐋🐋🌟🌟🌟
- 被 final 修饰的变量不可更改其引用地址，但是可以更改其内部属性。
- final修饰的**方法**不能被子类覆盖，但是可以被子类使用和重载。
- final 修饰类表示该类不可被继承。

### finally的实现原理
[finally的实现原理](https://cloud.tencent.com/developer/article/1811362)
Java 采用方式是复制 finally 代码块的内容，分别放在 try catch 代码块所有正常 return 和 异常 throw 之前。所以finally 代码块始终会执行。

在try语句的return块中，return 返回的变量并不是直接返回 i 值，而是在执行finally块之前把i值**存储在临时区域**，当执行return时直接返回的临时区域中的值，即使在finally语句中把变量 i 的值修改了，也不会影响返回的值。

![](https://github.com/qingzhu0214/JavaPage/raw/wuzu/_posts/image/finally.png)

### finally块中return语句发生异常
只有finally块，执行完成之后，才会回来执行try或者catch块中的return或者throw语句，如果finally中使用了return或者throw等终止方法的语句，则就不会跳回执行，直接停止。

### finally
[参考](https://blog.csdn.net/qq_35732831/article/details/104789779)

### 面向对象和面向过程的区别
面向过程（Procedure Oriented）：看名字它是注重过程的。当解决一个问题的时候，面向过程会把事情拆分成： 一个个函数和数据（用于方法的参数）。然后按照一定的顺序，执行完这些方法（每个方法看作一个个过程），等方法执行完了，事情就搞定了。

面向对象（Object Oriented）：看名字它是注重对象的。当解决一个问题的时候，面向对象会把事物抽象成对象的概念，就是说这个问题里面有哪些对象，然后给对象赋一些属性和方法，然后让每个对象去执行自己的方法，问题得到解决。

### 接口和抽象类的区别🐋🐋🌟
（1）接口只有定义，不能有方法的实现，java 1.8中可以定义default方法体，而抽象类可以有定义与实现，方法可在抽象类中实现。【抽象方法不能有实现，但是抽象类里面可以有其他的非抽象方法，并且有方法体】
（2）实现接口的关键字为implements，继承抽象类的关键字为extends。一个类可以实现多个接口，但一个类只能继承一个抽象类。所以，使用接口可以间接地实现多重继承。
（3）接口强调特定功能的实现，而抽象类强调所属关系。
（4）接口成员**变量**默认为public static final，必须赋初值，不能被修改；其所有的成员**方法**都是public、abstract的。抽象类中成员变量默认default，可在子类中被重新定义，也可被重新赋值；抽象方法被abstract修饰，不能被private、static、synchronized和native等修饰，必须以分号结尾，不带花括号。

***
[Java 8 中的接口和抽象类到底有啥区别？](https://cloud.tencent.com/developer/article/1730781)
- 首先抽象类是一个“类”，而接口只是一个“接口”，两者的概念和应用场景不一样，这也是抽象类和接口的主要区别。
- 即使在 Java 8 中接口也能写实现方法了，但却不能写构造方法，而在抽象类是可以写构造方法的，意味着抽象类是参与类的实例化过程的，而接口则不是。
- 抽象类可以有自己的各种成员变量，并且可以通过自己的**非抽象方法**进行改变，而接口中的变量默认全是 public static final 修饰的，意味着都是**常量**，并且不能被自己和外部修改。
- 接口可以实现多继承，而抽象类只能单继承。

### 接口中能使用什么修饰符？🐨
方法默认的修饰符是 public abstract；不可以使用private或者protected修饰。
变量默认的修饰符是 public static final。

### 抽象类和接口可以实例化吗🐋？
[参考](https://blog.csdn.net/u011047968/article/details/104716060)
抽象类不是具体的类，无法通过new的方式实例化，但是可以通过子类的构造方法间接实例化，也可以通过生成匿名类的方式来实现。

### 重载和重写的区别？🌟
**重载**发生在本类，方法名相同，参数列表不同，与返回值无关，只和方法名，参数的类型相关。
方法的**重写**发生在继承类，实现类之中，重写后的方法与原方法有完全相同的返回值类型，方法名，参数个数以及参数类型，但是具体实现不同。

### [多态的分类](https://zh.wikipedia.org/wiki/%E5%A4%9A%E6%80%81_(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6))
依据实现时做出的选择，多态可分为：
- 动态多态（dynamic polymorphism）:生效于运行期。
- 静态多态（static polymorphism）：将不同的特殊行为和单个泛化记号相关联，由于这种关联处理于编译期而非运行期，因此被称为“静态”。可以用来实现类型安全、运行高效的同质对象集合操作。C++ STL不采用动态多态来实现就是个例子。

参数多态(泛型)和子类型

子类型多态可分为变量多态与函数多态：
- 变量多态是指：基类型的变量（对于[C++](https://zh.wikipedia.org/wiki/C%2B%2B "C++")是引用或指针）可以被赋值基类型对象，也可以被赋值派生类型的对象。
- 函数多态是指，相同的函数调用界面（函数名与实参表），传送给一个对象变量，可以有不同的行为，这视该对象变量所指向的对象类型而定。

### Java异常体系🐋🐋🐋
-   错误（error）：当资源不足、约束失败、或是其它程序无法继续运行的条件发生时，就产生错误。程序本身无法修复这些错误，都是一些比较严重的问题，大多数错误与代码编写者执行的操作无关，而表示代码运行时JVM出现的问题，**如OutOfMemoryError、StackOverFlowError**等，这些异常发生时，JVM一般会选则终止。error表明系统JVM已经处于不可恢复的崩溃状态。
-   Exception：是程序本身能够处理的异常，如空指针、下标越界、类型转换等。Exception是所有异常类的超类，其子类对应了各种可能出现的异常事件，通常可分为：
    -   运行时异常：RuntimeException：这类异常通常是由编程错误导致的，所以在编写程序时，并**不要求必须使用异常处理机制处理**这类异常，而是经常需要通过增加“逻辑处理来避免这些异常”，常见的运行时异常有：**数组下标越界、空指针、被0除**等。
    -   检查异常：CheckedException:所有不是RuntimeException的异常，统称为CheckedException，它强迫程序员处理异常，大大增强程序的可靠性。如**IoException、SQLException**等以及用户自定义的Exception异常，这类异常在编译时就必须做出处理，否则无法通过编译。

### Exception和Error的区别
[参考](https://zhuanlan.zhihu.com/p/55826813)
Error 是 Java 程序运行中不可预料的异常情况，这种异常发生以后，会直接导致 JVM 不可处理或者不可恢复的情况。所以这种异常不可能抓取到，比如 OutOfMemoryError、NoClassDefFoundError等。

Exception 是 Java 程序运行中可预料的异常情况，我们可以获取到这种异常，并且对这种异常进行业务外的处理。它分为检查性异常和非检查性（RuntimeException）异常。两个根本的区别在于，检查性异常必须在编写代码时，使用 try catch 捕获（比如：IOException异常）。非检查性异常 在代码编写时，可以忽略捕获操作（比如：ArrayIndexOutOfBoundsException），这种异常是在代码编写或者使用过程中通过规范可以避免发生的。

### 运行时异常的特点

### 多线程生产者消费者
[参考](https://blog.csdn.net/chengyuqiang/article/details/79182006)
[参考](https://blog.csdn.net/csdn2497242041/article/details/120246090)

### [实现基于可重入锁的阻塞队列](https://cloud.tencent.com/developer/article/1837462)
阻塞队列：就是说当队列是空时，如果再继续从队列中获取数据，将会被阻塞，直到有新的数据入队列才停止阻塞；还有当队列已经满了（到达设置的最大容量），再往队列里添加元素的操作也会被阻塞，直到有数据从队列中被移除。

这里首先要有一个锁，保证同时只能有一个线程执行出队列、同时只能有一个线程执行入队列。而执行出队列和入队列的线程的阻塞和唤醒，是靠wait()方法和notifyAll()方法来实现的。

Condition：
-   **await()**：阻塞当前线程，并释放锁。
-   **signal()**：唤醒一个等待时间最长的线程。

```java
class BlockQueue {
    ReentrantLock lock = new ReentrantLock(fair); // fair是布尔条件
    Condition notEmpty = lock.newCondition(); // 非空条件
    Condition notFull = lock.newCondition(); // 非满条件

    public void put() {
        lock.lockInterruptibly();
        try {
            while (count == item.length) notFull.await();
            enqueue(e) // 入队
        } finally {
            lock.unlock();
        }
    }

    private void enqueue(E x) {
        notEmpty.signal(); // 入队的数组操作
    }

    public E take() {
        lock.lockInterruptibly();
        try {
            while (count == 0) notEmpty.await();
            return dequeue();
        } finally {
            lock.unlock();
        }
    }

    private E dequeue() {
        notFull.signal(); // 数组出队操作
        return x;
    }
}
```

### Java反射🌟
Java反射机制的核心是在程序运行时动态加载类并获取类的详细信息，从而操作类或对象的属性和方法。

-   反射让开发人员可以通过外部类的全路径名创建对象，并使用这些类，实现一些扩展的功能。
-   反射让开发人员可以枚举出类的全部成员，包括构造函数、属性、方法。以帮助开发者写出正确的代码。
-   测试时可以利用反射 API 访问类的私有成员，以保证测试代码覆盖率。

```java
// 1.通过字符串获取Class对象，这个字符串必须带上完整路径名
Class studentClass = Class.forName("com.test.reflection.Student");
// 2.获取声明的构造方法，传入所需参数的类名，如果有多个参数，用','连接即可
Constructor studentConstructor = studentClass.getDeclaredConstructor(String.class);
// 如果是私有的构造方法，需要调用下面这一行代码使其可使用，公有的构造方法则不需要下面这一行代码
studentConstructor.setAccessible(true);
// 使用构造方法的newInstance方法创建对象，传入构造方法所需参数，如果有多个参数，用','连接即可
Object student = studentConstructor.newInstance("NameA");
// 3.获取声明的字段，传入字段名
Field studentAgeField = studentClass.getDeclaredField("studentAge");
// 如果是私有的字段，需要调用下面这一行代码使其可使用，公有的字段则不需要下面这一行代码
// studentAgeField.setAccessible(true);
// 使用字段的set方法设置字段值，传入此对象以及参数值
studentAgeField.set(student,10);
// 4.获取声明的函数，传入所需参数的类名，如果有多个参数，用','连接即可
Method studentShowMethod = studentClass.getDeclaredMethod("show",String.class);
// 如果是私有的函数，需要调用下面这一行代码使其可使用，公有的函数则不需要下面这一行代码
studentShowMethod.setAccessible(true);
// 使用函数的invoke方法调用此函数，传入此对象以及函数所需参数，如果有多个参数，用','连接即可。函数会返回一个Object对象，使用强制类型转换转成实际类型即可
Object result = studentShowMethod.invoke(student,"message");
System.out.println("result: " + result);
```

### 为什么重写equals以后还要重写hashcode？
对比两个对象相等，最快的方法是对比hashcode，因为不同的对象，hashcode一定不同，当hashcode相等的时候，再用equals来再次判断一下。

不重写hashcode，可能会导致理论上应该相等的值，在map操作时需要进行覆盖的值，实际上因为hashcode不同，而导致重复。因为**hashcode未重写前，部分依据是地址**，而对于地址不同的，那么hashcode一定不同。

但是对于不太好的重写，那么存在这样一种可能：两个不同的对象，按照重写的hashcode，巧合性的相等，equals也相等，新值覆盖了旧值。

### 乐观锁和悲观锁
[乐观锁和悲观锁](https://www.cnblogs.com/kismetv/p/10787228.html)
[参考](https://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&mid=2651749434&idx=3&sn=5ffa63ad47fe166f2f1a9f604ed10091&chksm=bd12a5778a652c61509d9e718ab086ff27ad8768586ea9b38c3dcf9e017a8e49bcae3df9bcc8&scene=38#wechat_redirect)
-   乐观锁：乐观锁在操作数据时非常乐观，认为别人不会同时修改数据。因此乐观锁不会上锁，只是在执行更新的时候判断一下在此期间别人是否修改了数据：如果别人修改了数据则放弃操作，否则执行操作。
-   悲观锁：悲观锁在操作数据时比较悲观，认为别人会同时修改数据。因此操作数据时直接把数据锁住，直到操作完成后才会释放锁；上锁期间其他人不能修改数据。

悲观锁的实现方式是加锁，加锁既可以是对代码块加锁（如Java的synchronized关键字），也可以是对数据加锁（如MySQL中的排它锁）。

乐观锁的实现方式主要有两种：CAS机制和版本号机制。

CAS操作逻辑如下：如果内存位置V的值等于预期的A值，则将该位置更新为新值B，否则不进行任何操作。许多CAS的操作是自旋的：如果操作不成功，会一直重试，直到操作成功为止。CAS是由CPU支持的原子操作，其原子性是在硬件层面进行保证的。

```java
// 注意变量要声明为volatile
for (;;) {
    int current = get();
    int next = current + 1;
    if (compareAndSet(current, next))
        return current;
}
```

版本号机制的基本思路是在数据中增加一个字段version，表示该数据的版本号，每当数据被修改，版本号加1。当某个线程查询数据时，将该数据的版本号一起查出来；当该线程更新数据时，判断当前版本号与之前读取的版本号是否一致，如果一致才进行操作。

CAS只能保证单个变量操作的原子性，当涉及到多个变量时，CAS是无能为力的，而synchronized则可以通过对整个代码块加锁来处理。再比如版本号机制，如果query的时候是针对表1，而update的时候是针对表2，也很难通过简单的版本号来实现乐观锁。

**ABA问题**
在某些场景下，ABA却会带来隐患，例如栈顶问题：一个栈的栈顶经过两次(或多次)变化又恢复了原值，但是栈可能已发生了变化。
对于ABA问题，比较有效的方案是引入版本号，内存中的值每发生一次变化，版本号都+1；在进行CAS操作时，不仅比较内存中的值，也会比较版本号，只有当二者都没有变化时，CAS才能执行成功。

**高竞争下的开销问题**
在并发冲突概率大的高竞争环境下，如果CAS一直失败，会一直重试，CPU开销较大。针对这个问题的一个思路是引入退出机制，如重试次数超过一定阈值后失败退出。

**功能限制**
(1)原子性不一定能保证线程安全，例如在Java中需要与volatile配合来保证线程安全；
(2)当涉及到多个变量(内存值)时，CAS也无能为力。

### Java多线程开发用过哪些？
[参考](https://www.cnblogs.com/wxd0108/p/5479442.html)
Synchronized、volatile
基本线程类：Thread类，Runnable接口，Callable接口
多线程包：java.util.concurrent
ThreadLocal类：ThreadLocal为每个使用该变量的线程提供独立的变量副本，所以每一个线程都可以独立地改变自己的副本，而不会影响其它线程所对应的副本。
原子类（AtomicInteger、AtomicBoolean……）
Lock类：比synchronized性能更高
容器类：BlockingQueue、ConcurrentHashMap
管理类：ThreadPoolExecutor和 JMX框架下的系统级管理类 ThreadMXBean

### StringBuilder和StringBuffer哪个是线程安全的？🐋
StringBuilder和StringBuffer都继承了AbstractStringBuilder.

AbstractStringBuilder的append方法：
```java
public AbstractStringBuilder append(String str) {  
    if (str == null)  
        return appendNull();  
	 int len = str.length();  
	 ensureCapacityInternal(count + len);  
	 str.getChars(0, len, value, count);  
	 count += len;  
	 return this;
 }
```

count += len不是一个原子操作。假设这个时候count值为10，len值为1，两个线程同时执行到了第七行，拿到的count值都是10，执行完加法运算后将结果赋值给count，所以两个线程执行完后count值为11，而不是12。

而StringBuffer的append方法前面多加了synchronized.

### 什么是线程安全？Java怎么保证线程安全？🌟🌟🌟
[什么是线程安全？Java怎么保证线程安全？](https://segmentfault.com/a/1190000038320670)
《深入Java虚拟机》的定义：
当多个线程访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那这个对象就是线程安全的。

方法一：使用synchronized关键字
方法二：使用Lock接口下的实现类。常用的实现类就是ReentrantLock 类，它其实也是一种悲观锁。
方法三：使用线程本地存储ThreadLocal。
方法四：使用乐观锁机制。

###  Java内部有哪些同步的机制🐋🌟🌟
[JAVA内部用来实现同步的几种方式](https://my.oschina.net/st9/blog/680669)
1. synchronized修饰的同步方法，当方法是非静态的方法时候，内置锁为当前对象实例，为静态方法时候，是内置锁会锁住整个类。
2. synchronized修饰的同步代码块
3. 使用特殊域变量(volatile)实现线程同步
4. 使用重入锁(ReenreantLock)实现线程同步

Java平台提供的同步机制有锁、volatile关键字、final关键字、wait/notifyAll以及并发包下的工具类如：Semaphore、Condition等。

**深入理解Java虚拟机书上的答案：**

**互斥同步：**
	1. synchronized关键字
		synchronized关键字经过Javac编译之后，会在同步块的前后分别形成monitorenter monitorexit这两个字节码指令。这两个字节码指令都需要一个reference类型的参数来指明 要锁定和解锁的对象。如果Java源码中的synchronized明确指定了对象参数，那就以这 对象的引用作为reference；如果没有明确指定，那将根据synchronized修饰的方法类型（ 实例方法或类方法），来决定是取代码所在的**对象实例**还是取类型对应的**Class对象**来作为线程要持有的锁。
		在执行monitorenter指令时，首先要去尝试获取对象的锁。如果这个对象没被锁定，或者当前线程已经持有了那个对象的锁，就把锁的计数器的值增加一，而在执行monitorexit指令时会将锁计数器的值减一。一旦计数器的值为零，锁随即就被释放了。如果获取对象锁失败，那当前线程就应当被阻塞等待，直到请求锁定的对象被持有它的线程释放为止。
	2. Lock接口

**非阻塞同步：**
CAS操作：AtomicInteger
ABA问题：J.U.C包为了解决这个问题，提供了一个带有标记的原子引用AtomicStampedReference，它可以通过控制变量值的版本来保证CAS的正确性。

**无同步方案：**
可重入代码：可重入代码有一些共同的特征，例如，不依赖全局变量、存储在堆上的数据和公用的系统资源，用到的状态量都由参数中传入，不调用非可重入的方法等。

线程本地存储（Thread Local Storage）：如果一段代码中所需要的数据必须与其他代码共享，那就看看这些共享数据的代码是否能保证**在同一个线程中执行**。如果能保证，我们就可以把共享数据的可见范围限制在同一个线程之内，这样，无须同步也能保证线程之间不出现数据争用的问题。

可以通过java.lang.ThreadLocal类来实现线程本地存储的功能。每一个线程的Thread对象中都有一个ThreadLocalMap对象，这个对象存储了一组以ThreadLocal.threadLocalHashCode为键，以本地线程变量为值的K-V值对，ThreadLocal对象就是当前线程的ThreadLocalMap的访问入口，每一个ThreadLocal对象都包含了一个独一无二的threadLocalHashCode值，使用这个值就可以在线程K-V值对中找回对应的本地线程变量。

### threadLocal🌟
[参考](https://juejin.cn/post/6959333602748268575)
ThreadLocal是一个关于创建线程局部变量的类。通常情况下，我们创建的变量是可以被任何一个线程访问并修改的。而使用ThreadLocal创建的变量只能被当前线程访问，其他线程则无法访问和修改。

由于ThreadLocal里设置的值，只有当前线程自己看得见，这意味着你不可能通过其他线程为它初始化值。
ThreadLocal.ThreadLocalMap是一个比较特殊的Map，它的每个Entry的key都是一个弱引用。这样设计的好处是，如果这个变量不再被其他对象使用时，【不存在外部强引用的时候】可以自动回收这个ThreadLocal对象，避免可能的内存泄露。

对于ThreadLocalMap，它使用的是简单的线性探测法，如果发生了元素冲突，那么就使用下一个槽位存放。

在实际开发过程中，我们可能会遇到这么一种场景。主线程开了一个子线程，但是我们希望在子线程中可以访问主线程中的ThreadLocal对象，也就是说有些数据需要进行父子线程间的传递。将上述代码中的threadLocal使用InheritableThreadLocal。

```java
public class ThreadLocalDemo {
    
    public static void main(String[] args) throws InterruptedException {

        final ThreadLocal<String> threadLocal = new ThreadLocal<>();
        threadLocal.set("main-thread : Hello");
        
        Thread thread = new Thread(() -> {
            // 获取不到主线程设置的值，所以为null
            System.out.println(threadLocal.get());
            threadLocal.set("sub-thread : World");
            System.out.println(threadLocal.get());
        });
        // 启动子线程
        thread.start();
        // 让子线程先执行完成，再继续执行主线
        thread.join();
        // 获取到的是主线程设置的值，而不是子线程设置的
        System.out.println(threadLocal.get());
        threadLocal.remove();
        System.out.println(threadLocal.get());
    }
```

```
null
sub-thread : World
main-thread : Hello
null
```

### ThreadLocal会有什么问题？🐋
ThreadLocal被ThreadLocalMap中的entry的key弱引用，如果出现GC的情况时，没有被其他对象引用，会被回收，但是ThreadLocal对应的value却不会回收，容易造成内存泄漏。

### Lock接口的实现类
[Lock接口与实现类](https://www.jianshu.com/p/3481a39c50f6)
[JUC并发核心AQS同步队列原理详解](https://blog.csdn.net/u012988901/article/details/112251913)

ReentrantLock：这些锁在同一时刻只允许一个线程进行访问，而读写锁在同一时刻可以允许多个读线程访问，但是在写线程访问时，所有的读线程和其他写线程均被阻塞。

ReentrantReadWriteLock：读写锁维护了一对锁，一个读锁和一个写锁，通过分离读锁和写锁，使得并发性相比一般的排他锁有了很大提升。

读写锁资源控制的一个整型变量使用了位运算进行“按位切割”，高16位表示读，低16位表示写。
假设当前同步状态值为S，写状态等于S&0x0000FFFF（将高16位全部抹去），读状态等于S>>>16（无符号补0右移16位）。当写状态增加1时，等于S+1，当读状态增加1时，等于S+(1<<16)，也就是S+0x00010000。

根据状态的划分能得出一个推论：S不等于0时，当写状态（S&0x0000FFFF）等于0时，则读状态（S>>>16）大于0，即读锁已被获取。

写锁是一个支持重进入的排它锁。如果当前线程已经获取了写锁，则增加写状态。如果当前线程在获取写锁时，读锁已经被获取（读状态不为0）或者该线程不是已经获取写锁的线程，则当前线程进入等待状态。

### 多线程的工具类
[参考链接](https://blog.csdn.net/qq_33753147/article/details/106123434)

CountDownLatch：是一组线程等待其他的线程完成工作以后在执行，加强版join。
await用来等待，countDown负责计数器的减一。countDownLatch设定的次数必须减少到0，await的方法才会被唤醒向下继续执行，否则当一直处于阻塞状态。

CyclicBarrier：

```java
// 让一组线程达到某个屏障，被阻塞，一直到组内最后一个线程达到屏障时，屏障开放，所有被阻塞的线程会继续运行
CyclicBarrier(int parties) 

// 屏障开放，barrierAction定义的任务会执行
CyclicBarrier(int parties, Runnable barrierAction)
```

Semaphore：控制同一时刻方法资源的数量
```java
// 表示同时获得资源数量
Semaphore(int permits)

// 从信号量容器中获取可用的信号量，信号量数量-1，如果没有可用信号量则阻塞
acquire()

// 归还信号量到信号量容器中，信号量数量+1
release()
```

Exchange：只能两个线程间的数据交换

Callable, Future & FutureTask：

### 创建线程的方法🐋🐋🐋🌟
[参考](https://segmentfault.com/a/1190000022878543)
1. 定义Thread类的子类，并重写该类的run方法，创建Thread子类的实例，调用线程对象的start()方法来启动该线程。
2. 定义Runnable接口的实现类，并重写该接口的run()方法，创建Runnable实现类的实例，并以此实例作为Thread的参数来创建Thread对象，该Thread对象才是真正的线程对象。调用线程对象的start()方法来启动该线程。
3. 创建Callable接口的实现类，并实现call()方法，创建Callable实现类的实例，使用FutureTask类来包装Callable对象，该FutureTask对象封装了该Callable对象的call()方法的返回值。使用**FutureTask对象**作为Thread对象的参数创建并启动新线程。调用FutureTask对象的get()方法来获得子线程执行结束后的返回值。
4. 使用线程池

Runnable接口和Callable接口的区别：
- 实现Callable接口的任务线程能返回执行结果，而实现Runnable接口的任务线程不能返回执行结果
- Callable接口实现类中run()方法允许将异常向上抛出，也可以直接在内部处理(try…catch); 而Runnable接口实现类中run()方法的异常必须在内部处理掉，不能向上抛出

前三种方法是调用`new Thread(xxx).start()`启动线程
线程池是
```java
ExecutorService executorService = Executors.newFixedThreadPool(10);
executorService.execute(new MyThread());
```

### Java中有哪些线程池？🌟
[Java中有哪些线程池？](https://www.cnblogs.com/gaopengpy/p/12148971.html)
- newCachedThreadPool创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。
	工作线程的创建数量几乎没有限制(其实也有限制的,数目为Interger. MAX_VALUE), 这样可灵活的往线程池中添加线程。
- newFixedThreadPool 创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。
- newScheduledThreadPool 创建一个定长线程池，支持定时及周期性任务执行。
- newSingleThreadExecutor 创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。
- newSingleThreadScheduledExecutor：创建一个单线程执行程序，它可安排在给定延迟后运行命令或者定期地执行。线程池中最多执行1个线程，之后提交的线程活动将会排在队列中以此执行并且可定时或者延迟执行线程活动。

### 线程池的几个重要参数🐋🐋🌙🌟
[线程池的几个重要参数](https://blog.csdn.net/qq_35989077/article/details/87179720)
1. corePoolSize ：【线程池核心线程数量】保留在池中的线程数，即使它们是空闲的，除非设置了  allowCoreThreadTimeOut；
2. maximumPoolSize ：池中允许的最大线程数；
3. keepAliveTime ：当线程数大于核心时，这是多余的空闲线程在终止前等待新任务的最长时间；
4. unit ：keepAliveTime 参数的时间单位；
5. workQueue ：用于在执行任务之前保存任务的队列。 此队列将仅保存由 execute 方法提交的 Runnable 任务。
6. threadFactory ：执行器创建新线程时使用的工厂；
7. handler：由于达到线程边界和队列容量而阻塞执行时使用的处理方法。
	四种拒绝策略：
	- CallerRunsPolicy：提交任务的线程自己去执行该任务。
　- AbortPolicy：默认的拒绝策略，会 throws RejectedExecutionException。
　- DiscardPolicy：直接丢弃任务，没有任何异常抛出。
　- DiscardOldestPolicy：丢弃最老的任务，其实就是把最早进入工作队列的任务丢弃，然后把新任务加入到工作队列。

如果是 CPU 密集型的，可以把核心线程数设置为核心数+1。
IO密集型设置为 2* CPU 核心数

### 一个任务放入线程池的过程🌟
[一个任务放入线程池的过程](https://www.cnblogs.com/chiangchou/p/thread-pool.html)

![](https://github.com/qingzhu0214/JavaPage/raw/wuzu/_posts/image/xczx.png)

- 提交任务后，如果线程数小于 corePoolSize，则创建新线程执行任务，无论当前线程池的线程是否空闲都会创建新的线程。
- 当创建的线程数等于 corePoolSize 时，提交的任务会被加入到设置的阻塞队列中。
- 当队列满了，则会创建非核心线程执行任务，直到线程池中的线程数量等于 maximumPoolSize。【如果队列满了，但是正在运行的线程数量少于maximumPoolSize，则创建非核心线程运行这个任务】
- 当线程数量已经等于 maximumPoolSize 时， 新提交的任务无法加入到等待队列，也无法创建非核心线程直接执行，如果没有为线程池设置拒绝策略，这时线程池就会抛出 RejectedExecutionException 异常，即默认拒绝接受任务。

### Java线程池的实现
[参考](https://juejin.cn/post/6968721240592744455)
在线程池中，使用了一个原子类AtomicInteger的变量来表示线程池状态和线程数量，该变量在内存中会占用4个字节，也就是32bit，其中高3位用来表示线程池的状态，低29位用来表示线程的数量。线程池的状态一共有5种状态，用3bit最多可以表示8种状态，因此采用高3位来表示线程池的状态完全能满足需求。

ctl 是一个涵盖了两个概念的原子整数类，它将工作线程数和线程池状态结合在一起维护，低 29 位存放 workerCount，高 3 位存放 runState。

![](https://github.com/qingzhu0214/JavaPage/raw/wuzu/_posts/image/线程池实现.png)

### 线程池的状态🌟
-   RUNNING：能接受新任务，并处理阻塞队列中的任务
-   SHUTDOWN：不接受新任务，但是可以处理阻塞队列中的任务
-   STOP：不接受新任务，并且不处理阻塞队列中的任务，并且还打断正在运行任务的线程，就是直接撂担子不干了！
-   TIDYING：所有任务都终止，并且工作线程也为0，处于关闭之前的状态
-   TERMINATED：已关闭。

![](https://github.com/qingzhu0214/JavaPage/raw/wuzu/_posts/image/线程池生命周期.png)

[参考资料](https://juejin.cn/post/6844904000056197127)

### 如何监控 Java 线程池运行状态
线程池执行类 ThreadPoolExecutor 也给出了相关的 API, 能实时获取线程池的当前活动线程数、正在排队中的线程数、已经执行完成的线程数、总线程数等。

总线程数 = 排队线程数 + 活动线程数 + 执行完成的线程数。

```java
private static ExecutorService es = new ThreadPoolExecutor(50, 100, 0L, TimeUnit.MILLISECONDS,
            new LinkedBlockingQueue<Runnable>(100000));

ThreadPoolExecutor tpe = ((ThreadPoolExecutor) es);
// 排队线程数
int queueSize = tpe.getQueue().size();
// 当前活动线程数
int activeCount = tpe.getActiveCount();
// 执行完成线程数
long completedTaskCount = tpe.getCompletedTaskCount();
// 总线程数
long taskCount = tpe.getTaskCount();
```

### 建立一个线程池
[参考](https://cloud.tencent.com/developer/article/1638175)
```java
public class ExecutorsDemo {
    private static ExecutorService executor = Executors.newFixedThreadPool(15);
    public static void main(String[] args) {
        for (int i = 0; i < Integer.MAX_VALUE; i++) {
            executor.execute(new SubThread());
        }
    }
}

class SubThread implements Runnable {
    @Override
    public void run() {
        try {
            Thread.sleep(10000);
        } catch (InterruptedException e) {
            //do nothing
        }
    }
}
```

OOM的原因：
不设置的话，将是一个无边界的阻塞队列，最大长度为Integer.MAX_VALUE。也就是说，如果我们不设置LinkedBlockingQueue的容量的话，其默认容量将会是Integer.MAX_VALUE。

### shutdown和shutdownNow的区别
[参考](http://www.codebaoku.com/it-java/it-java-223973.html)
shutdown()，它可以安全地关闭一个线程池，调用 shutdown() 方法之后线程池并不是立刻就被关闭，因为这时线程池中可能还有很多任务正在被执行，或是任务队列中有大量正在等待被执行的任务，调用 shutdown() 方法后线程池会在执行完正在执行的任务和队列中等待的任务后才彻底关闭。调用 shutdown() 方法后如果还有新的任务被提交，线程池则会根据拒绝策略直接拒绝后续新提交的任务。

在执行 shutdownNow 方法之后，首先会给所有线程池中的线程发送 interrupt 中断信号，尝试中断这些任务的执行，然后会将任务队列中正在等待的所有任务转移到一个 List 中并返回。

### 如何停止线程
- 判断 `this.isInterrupted()`是否为true，编写相应的中断操作，抛出`throw new InterruptedException();`异常
- `thread.stop();`非常暴力，如果强制让线程停止有可能使一些清理性的工作得不到完成。另外一个情况就是对锁定的对象进行了解锁，导致数据得不到同步的处理，出现数据不一致的问题。
- 将方法interrupt()与return结合使用也能实现停止线程的效果；

### Java线程池的缺陷
1.  适用于生存周期较短的的任务，不适用于又长又大的任务。
2.  不能对于线程池中任务设置优先级。
3.  不能标识线程的各个状态，比如启动线程，终止线程。
4.  对于任意给定的应用程序域，只能允许一个线程池与之对应。
5.  线程池所有线程都处于多线程单元中，如果想把线程放到单线程单元中，线程池就废掉了。

### 多线程使用需要注意什么
[参考](https://blog.csdn.net/weixin_30965253/article/details/115088417)
- 线程之间的安全性
- 线程之间的死循环过程
- 线程太多了会将服务器资源耗尽形成死机宕机

### 池化技术
池化技术的优点主要有两个：提前准备和重复利用。
常见的池化技术的应用有：线程池、内存池、数据库连接池、HttpClient 连接池等。

### 如果CPU持续占满，从线程池角度排查一下原因
- 没有限定创建线程的数量，大量线程处于BLOCKED和WAITING状态。
- CPU使用率的飙升更多是由于上下文切换或过多的可运行状态线程。处于阻塞状态的线程不一定会导致CPU使用率上升。

### Java访问修饰符的作用范围
- 定义为public的class、interface可以被其他任何类访问
- 定义为private的field、method无法被其他类访问
- protected作用于继承关系。定义为protected的字段和方法可以被子类访问，以及子类的子类
- 包作用域是指一个类允许访问同一个package的没有public、private修饰的class，以及没有public、protected、private修饰的字段和方法。

若子类与父类不在同一包中，那么在子类中，子类实例可以访问其从父类继承而来的protected方法，而不能访问父类实例的protected方法。

### static和 abstract可以同时修饰一个方法吗？
abstract与static不能同时使用，static关键字修饰的成员是属于类的，而abstract一般是用来修饰普通方法目的是为了让子类继承后重写该方法，而static修饰的方法是不存在继承重写的。

### float f = 3.14;能通过编译吗？🐨
不正确，赋值运算符（=）左右两边的精度类型不匹配。在默认情况下，包括小数点的实数，如本题中的3.14，被存储为double类型（即双精度），而float类型定义的变量，如本题中的f，即是单精度的。如果想让上面的语句编译正确，应该对赋值运算符（=）右边的值做强制类型转换，即把常量3.14强制转换为单精度（即float类型）

```java
float f = (float)3.14;
float f = 3.14f;
float f = 3.14F;
```

### 接口中能使用什么修饰符？
接口中的变量：public static final
接口中的方法：public abstract

### Java是如何编译文件的?
[Java是如何编译文件的?](https://juejin.cn/post/6844903635789283342)
- 词法分析：从左到右一个字符一个字符地读入源程序，将字符序列转换为标记（token）序列。
- 语法分析：在词法分析的基础上将单词序列组合成各类语法短语，如“程序”，“语句”，“表达式”等等。语法分析程序判断源程序在结构上是否正确。
- 语义分析：对结构上正确的源程序进行上下文有关性质的审查，进行类型审查。语义分析是审查源程序有无语义错误，为代码生成阶段收集类型信息。语义分析的一个重要部分就是类型检查。

通过 javac 将程序源代码编译，转换成 Java 字节码，JVM 通过解释字节码将其翻译成对应的机器指令，逐条读入，逐条解释翻译。

经过解释执行，其执行速度必然会比可执行的二进制字节码程序慢很多。这就是传统的JVM的解释器（Interpreter）的功能。为了解决这种效率问题，引入了  JIT 技术。

JAVA程序还是通过解释器进行解释执行，当JVM发现某个方法或代码块运行特别频繁的时候，就会认为这是“热点代码”（Hot Spot Code)。然后JIT会把部分“热点代码”翻译成本地机器相关的机器码，并进行优化，然后再把翻译后的机器码 缓存起来，以备下次使用。

基于计数器的热点探测（Counter Based Hot Spot Detection)。采用这种方法的虚拟机会为每个方法，甚至是代码块建立计数器，统计方法的执行次数，某个方法超过阀值就认为是热点方法，触发JIT编译。

### Objects中equals和hashcode
equals()比较的是两个对象的内存地址是否相等。
hashCode()是native方法，也就是非java语言写的外部方法。

重写后需要保证当equals(Object)方法两个对象相等时，两个对象的hashCode()产生相同的整数结果；当equals(Object)方法两个对象不相等时，尽量保证两个对象的hashCode()产生不相同的整数结果

### Objects中equals和hashcode
hashcode：

```java
public native int hashCode();
```

hashCode返回对象的内存地址经过处理后的结构，由于每个对象的内存地址都不一样，所以哈希码也不一样。

String类的hashcode：//s[0] * 31^(n-1) + s[1] * 31^(n-2) + ... + s[n-1]

```java
public boolean equals(Object obj) {
	return (this == obj);
}
```

在Object这个类里面提供的equals()方法默认的实现是比较当前对象的引用和你要比较的那个引用它们指向的是否是同一个对象。

String类比较：
1. 对象的指向比较，理解为两个对象的内存地址是否一样
2. anObject instanceof String
3. 依次比较长度和里面的值

一般我们在设计一个类时，需要重写父类的equals方法，在重写这个方法时，需要按照以下几个规则设计：
1. 自反性：对任意引用值x，x.equals(x)的返回值一定为true；
2. 对称性：对于任何引用值x，y，当且仅当y.equals(x)返回值为true时，x.equals(y)的返回值一定为true;
3. 传递性：如果x.equals(y)=true, y.equals(z)=true，则x.equals(z)=true；
4. 一致性：如果参与比较的对象没任何改变，则对象比较的结果也不应该有任何改变；
5. 非空性：任何非空的引用值x，x.equals(null)的返回值一定为false。

### String之“=\=”和“equals”的🐋区别
String的equals（）方法比较的是字符串的内容，==比较的是内存地址值。

### 阻塞队列的选型和长度
[参考](https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/Java%20%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%2078%20%E8%AE%B2-%E5%AE%8C/38%20%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%E9%80%82%E5%90%88%E8%87%AA%E5%B7%B1%E7%9A%84%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%EF%BC%9F.md)
![](https://github.com/qingzhu0214/JavaPage/raw/wuzu/_posts/image/阻塞队列.png)

- 由于 FixedThreadPool 的线程数是固定的，在任务激增的时候，它无法增加更多的线程来帮忙处理 Task，所以需要像 LinkedBlockingQueue 这样没有容量上限的 Queue 来存储那些还没处理的 Task。
- 对于 CachedThreadPool 而言，为了避免新提交的任务被拒绝，它选择了无限制的 maximumPoolSize（在专栏中，maxPoolSize 等同于 maximumPoolSize），所以既然它的**线程的最大数量是无限的**，也就意味着它的线程数不会受到限制，那么它就不需要一个额外的空间来存储那些 Task，因为每个任务都可以通过新建线程来处理。
- 延迟队列的特点是：不是先进先出，而是会按照延迟时间的长短来排序，下一个即将执行的任务会排到队列的最前面。

### JDK有哪些包
java.lang----包含一些Java语言的核心类，如String、Math、Integer，System和Thread，提供常用功能。
java.net----包含执行与网络相关的操作的类和接口。
java.io   ----包含能提供多种输入/输出功能的类。
java.util----包含一些实用工具类，如定义系统特性、接口的集合框架类、 使用与日期日历相关的函数。
java.text----包含了一些java格式化相关的类。
java.sql----包含了java进行JDBC数据库编程的相关类/接口
java.awt----包含了构成抽象窗口工具集（abstract window toolkits）的 多个类，这些类被用来构建和管理应用程序的图形用户界面(GUI)。
java.applet----包含applet运行所需的一些类。

### 反射的作用和底层原理
[参考](https://cloud.tencent.com/developer/article/1614318)
Java的反射机制允许我们动态的调用某个对象的方法/构造函数、获取某个对象的属性等，而无需在编码时确定调用的对象。

类加载过程：
1. 通过全限定名来获取定义此类的二进制字节流.
2. 将二进制字节流的静态存储结构转化为方法区的运行时数据结构.
3. 在内存中生成这个类的java.lang.Class对象, 作为方法区这个类的数据访问入口.

比如创建一个Student类，那么，JVM就会创建一个Student对应Class类的Class对象，该Class对象保存了Student类相关的类型信息。

### 反射🐋
反射机制是在运行时，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意个对象，都能够调用它的任意一个方法。在java中，只要给定类的名字，就可以通过反射机制来获得类的所有信息。

JDBC加载MySQL的驱动类时用到了反射。
开发各种通用框架（例如 Spring），许多框架都是配置化的，为了保证框架的通用性，可能需要根据配置文件加载不同的类或者对象，调用不同的方法，这个时候就必须使用到反射了，运行时动态加载需要的加载的对象。

使用场景：
Bean、代理模式、IDE自动提示功能，对象（提示：属性、方法）

***
Java的反射（reflection）机制是指在程序的运行状态中，可以构造任意一个类的对象，可以了解任意一个对象所属的类，可以了解任意一个类的成员变量和方法，可以调用任意一个对象的属性和方法。这种动态获取程序信息以及动态调用对象的功能称为Java语言的反射机制。

### 反射原理
[参考](https://segmentfault.com/a/1190000040206885)
Method 的 invoke 方法，其实是返回接口MethodAccessor的invoke方法。实际的MethodAccessor实现有两个版本,一个是Java版本,一个是native版本。为了尽可能地减少性能损耗：
- Java方法在被反射调用时,开头若干次使用native版
- 等反射调用次数超过阈值时则生成一个专用的MethodAccessor实现类,生成其中的invoke() 方法的字节码
- 以后对该Java方法的反射调用就会使用Java版本

### Java反射的三种实现方式🐋
Foo foo = new Foo();
**获取Class：**
1. 通过Object类的getClass方法  `Class cla = foo.getClass();`
2. 通过Class.forName方式 `Class cla = Class.forName( "xx.xx.Foo" );`

**利用反射创建对象：**
- 对于有空构造函数的类 可以直接用字节码文件获取实例：
	Object o = clazz.newInstance();
- 对于没有空的构造函数的类则需要先获取到他的构造对象，再通过该构造方法类获取实例：
```java
// 获取构造函数
Constroctor constroctor = clazz.getConstructor(String.class, int.class );
// 通过构造器对象的newInstance方法进行对象的初始化
Object obj = constroctor.newInstance( "jack" , 18 );
```


### Java为什么被称为平台无关性语言？
前端编译主要指与源语言有关但与目标机无关的部分。Java中，我们所熟知的javac的编译就是前端编译。除了这种以外，我们使用的很多IDE，如eclipse，idea等，都内置了前端编译器。主要功能就是把.java代码转换成.class代码。

后端编译主要是将中间代码再翻译成机器语言。Java中，这一步骤就是Java虚拟机来执行的。

因为**Java Class文件可以在任何平台创建，也可以被任何平台的Java虚拟机装载并执行，所以才有了Java的平台无关性。**

### Java里面的线程和操作系统的线程一样吗？
JDK1.2之前，程序员们为JVM开发了自己的一个线程调度内核，而到操作系统层面就是用户空间内的线程实现。而到了JDK1.2及以后，JVM选择了更加稳健且方便使用的操作系统原生的线程模型，通过系统调用，将程序的线程交给了操作系统内核进行调度。

现在的Java中线程的本质，其实就是操作系统中的线程，Linux下是基于pthread库实现的轻量级进程，Windows下是原生的系统Win32 API提供系统调用从而实现多线程。


### ThreadLocal
[参考](https://feigaoalibaba.github.io/2018/06/08/InheritableThreadLocal/)
[参考，写得更好](https://segmentfault.com/a/1190000041264583)

### System.gc()
通过System.gc()或者Runtime.getRuntime().gc()的调用，会显式触发Full GC，同时对老年代和新生代进行回收，尝试释放被丢弃对象占用的内存。

然而System.gc()调用附带一个免责声明，无法保证对垃圾收集器的调用(无法保证马上触发GC)。

当我们直接调用System.gc()只会把这次gc请求记录下来，等到runFinalization=true的时候才会先去执行GC，runFinalization=true之后会在允许一次system.gc()。

当调用runFinalization()的时候justRanFinalization变为true；

### Java异常处理中throw与throws的用法区别
当某个方法可能会抛出某种异常时用于throws 声明可能抛出的异常，然后交给上层调用它的方法程序处理。
如： public void function() throws Exception{......}

throw是语句抛出一个异常

### jar包和war包的区别
[参考](https://blog.51cto.com/u_13410146/3069363)
1. war包和项目的文件结构保持一致，jar包则不一样
2. jar包里没有静态资源的文件（index.jsp）

从部署项目上看：
部署普通的spring项目用war包就可以，部署springboot项目用jar包就可以，因为springboot内置tomcat。

### JUC(java.util.concurrent)的其他类🐨
[参考](https://zhuanlan.zhihu.com/p/268694726)
- ThreadPoolExecutor
- 阻塞队列：ArrayBlockingQueue
- ConcurrentHashMap
- locks.ReentrantLock
- Semaphore：信号量，用于控制同时访问某些资源的线程个数，具体做法为通过调用acquire()获取一个许可，如果没有许可，则等待，在许可使用完毕后通过release()释放该许可，以便其他线程使用。
- CountDownLatch：基于线程计数器来实现并发访问控制，主要用于主线程等待其他子线程都执行完毕后执行相关操作。

### Java中的堆和栈，成员变量、静态变量的存放位置🐋
- 本地内存-元空间-方法区的最新实现：**类信息，运行时常量池**
- 堆：**静态变量，字符串常量池**

### sleep( ) 和 wait( ) 的区别🐋
- sleep方法是Thread线程类的方法，而wait是Object顶级类的方法
- sleep可以在任何地方使用，而wait只能在同步方法和同步块中使用
- sleep睡眠的时间到了之后，会自动唤醒，wait需要通过notify或notifyAll方法来唤醒
- sleep不会释放锁而wait会释放锁
- 当线程调用wait()，线程都会进入到waiting状态，当线程调用sleep(time)，或者wait(time)时，进入timed waiting状态

### Java int 和Integer的区别🐋
[参考](https://juejin.cn/post/6844903987276169229)
- Integer是int的包装类；int是基本数据类型；
- Integer变量必须实例化后才能使用；int变量不需要；
- Integer实际是对象的引用，指向此new的Integer对象；int是直接存储数据值 
- Integer的默认值是null；int的默认值是0。
- 泛型不支持int，但是支持Integer
- int 存储在栈中，Integer 对象的引用存储在栈空间中，对象的数据存储在堆空间中。

相同值下的 int 和 Integer 的比较结果：
- 两个通过new生成的变量，结果为false
- int 和 Integer 的值比较，若两者的值相等，则为true
- new 生成的Integer变量 和 非new 生成的Integer变量比较，结果为false
- 对于两个非new生成的Integer对象，进行比较时，如果两个变量的值在区间-128到127之间，则比较结果为true，如果两个变量的值不在此区间，则比较结果为false。

### 说一下JAVA中的泛型?🐋
[参考](https://zhuanlan.zhihu.com/p/75893830)
泛型实现了了参数化类型的概念，使得代码可以应用于多种类型。

泛型的优点：
1. 类型安全：我们在使用泛型之后，可以指定输入的类型，输入其他的就会报错。
2. 消除强制类型转换：也就是说我们不需要进行类型转化，直接存储、直接输出。
3. 只在编译器有效：也就是说在运行时泛型是无效的。这避免了jvm花费时间在运行时做额外的操作。

泛型的使用主要是在三个方面，泛型类、泛型接口、泛型方法。

泛型使用时需要注意：
1. 指定的具体类型必须是类，不能是int,float等这些基础类型
2. 不能对泛型类使用instanceof。

### 线程的生命周期
[参考](https://developer.huawei.com/consumer/cn/forum/topic/0202779877806640557?fid=0101592429757310384)

通用的线程生命周期总体上可以分为五个状态：初始状态、可运行状态、运行状态、休眠状态和终止状态。

Java中的线程生命周期总共可以分为六种状态：初始化状态（NEW）、可运行/运行状态（RUNNABLE）、阻塞状态（BLOCKED）、无时限等待状态（WAITING）、有时限等待状态（TIMED_WAITING）、终止状态（TERMINATED）。
![](image/java生命周期.png)

### 使用synchronized修饰静态方法和非静态方法有什么区别
[参考](https://www.cnblogs.com/jichi/p/12500695.html)

对象锁：
- 同一个对象在两个线程中分别访问该对象的两个同步方法：互斥
- 不同对象在两个线程中调用同一个同步方法：不互斥

类锁：
- 用类直接在两个线程中调用两个不同的同步方法：互斥
- 用一个类的静态对象在两个线程中都调用静态方法或都非静态方法：互斥
- 一个对象在两个线程中分别调用一个静态同步方法和一个非静态同步方法：不互斥
因为虽然是一个对象调用，但是两个方法的锁类型不同，调用的静态方法实际上是类对象在调用，即这两个方法产生的并不是同一个对象锁，因此不会互斥，会并发执行。

synchronized(XX.class)类锁
synchronized(this)对象锁

### Java中的有序性、可见性、原子性的理解？
[参考](https://www.cnblogs.com/shamo89/p/9069289.html)
Java内存模型具备一些先天的“有序性”，即不需要通过任何手段就能够得到保证的有序性，这个通常也称为happens-before 原则。如果两个操作的执行次序无法从happens-before原则推导出来，那么它们就不能保证它们的有序性，虚拟机可以随意地对它们进行重排序。

### IO模型🐋
[参考](https://cloud.tencent.com/developer/article/1684951)
阻塞IO模型、非阻塞IO模型、IO复用模型、信号驱动的IO模型、异步IO模型；前4种为同步IO操作，只有异步IO模型是异步IO操作。

- **阻塞IO模型**：进程发起IO系统调用后，进程被阻塞，转到内核空间处理，整个IO处理完毕后返回进程。操作成功则进程获取到数据。
- **非阻塞IO模型**：进程发起IO系统调用后，如果内核缓冲区没有数据，需要到IO设备中读取，进程返回一个错误而不会被阻塞；进程发起IO系统调用后，如果内核缓冲区有数据，内核就会把数据返回进程。
- **IO复用模型**：多个的进程的IO可以注册到一个复用器（select）上，然后用一个进程调用该select， select会监听所有注册进来的IO；如果select没有监听的IO在内核缓冲区都没有可读数据，select调用进程会被阻塞；而当任一IO在内核缓冲区中有可数据时，select调用就会返回；而后select调用进程可以自己或通知另外的进程（注册进程）来再次发起读取IO，读取内核中准备好的数据。
- **信号驱动IO模型**：当进程发起一个IO操作，会向内核注册一个信号处理函数，然后进程返回不阻塞；当内核数据就绪时会发送一个信号给进程，进程便在信号处理函数中调用IO读取数据。
- **异步IO模型**：当进程发起一个IO操作，进程返回（不阻塞），但也不能返回结果；内核把整个IO处理完后，会通知进程结果。如果IO操作成功则进程直接获取到数据。

![](image/IO模型1.png)

### String.intern()
[参考](https://www.cnblogs.com/Qian123/p/5707154.html)
String的intern()方法就是扩充常量池的一个方法；当一个String实例str调用intern()方法时，Java查找常量池中是否有相同Unicode的字符串常量，如果有，则返回其的引用，如果没有，则在常量池中增加一个Unicode等于str的字符串并返回它的引用；

### sleep和wait的区别
- sleep()方法是定义在Thread上的native方法, 在设定时间段内(精度取决于CPU)阻塞线程的执行, 但是并不更改线程的锁持有情况.
- wait()方法是定义在Object上的方法, 是java语言级的方法, 需要在同步块或者同步方法中进行调用, 会释放锁, 并进入锁对象的等待队列, 需要等到其他线程调用notify()方法释放锁后(实际上该线程同步块运行结束后才会释放锁), 重新竞争锁.

### 为什么在接口设计的时候推荐使用包装类型而不推荐使用基本数据类型？
包装类型的默认值都是null，而基本数据类型的默认值是一个固定值，如boolean是false，byte、short、int、long是0，float是0.0f等；通过异常来阻断程序的运行，进而可以被立马识别到这种线上问题。

学生的成绩：用包装类型的话，null的话证明没有考，0的话证明考了0分；但是如果我们用基本类型的话，这两种情况都是一个样的，没法区分的。

### Java集合体系
[参考](https://juejin.cn/post/6983299001298714632)
![](image/java集合.png)

### 循环中的剔除掉Arraylist中的元素安全吗？
[参考](https://blog.csdn.net/mine_song/article/details/70045180)
“快速失败”也就是 fail-fast，它是 Java 集合的一种错误检测机制。当多个线程对集合进行结构上的改变的操作时，有可能会产生 fail-fast 机制。

fail-fast 产生的原因就在于程序在对 collection 进行迭代时，某个线程对该 collection 在结构上对其做了修改，这时迭代器就会抛出 ConcurrentModificationException 异常信息，从而产生 fail-fast。

ArrayList 中无论 add、remove、clear 方法只要是涉及了改变 ArrayList 元素的个数的方法都会导致 modCount 的改变。所以我们这里可以初步判断由于 expectedModCount 得值与 modCount 的改变不同步，导致两者之间不等从而产生 fail-fast 机制。

fail-fast 解决办法：
- 在遍历过程中所有涉及到改变 modCount 值得地方全部加上 synchronized 或者直接使用 Collections.synchronizedList，这样就可以解决。但是不推荐，因为增删造成的同步锁可能会阻塞遍历操作。
- 使用 CopyOnWriteArrayList 来替换 ArrayList。

### 集合类继承
![](image/集合类.png)

### Happens-before原则
x happens-before y，并不是说 x 操作一定要在 y 操作之前被执行，而是说 x 的执行结果对于 y 是可见的，只要满足可见性，发生了重排序也是可以的。
- 如果操作 x 和操作 y 是同一个线程的两个操作，并且在代码上操作 x 先于操作 y 出现，那么有 hb(x, y)
- 对象构造方法的最后一行指令 happens-before 于 finalize() 方法的第一行指令。
- hb(x, y) 和 hb(y, z)，那么可以推断出 hb(x, z)

### 匿名内部类
[参考](https://www.jianshu.com/p/6afc0a57a466)
常见的匿名内部类的应用场合为： 需要通过实现接口来创建匿名内部类。
通过继承抽象父类来创建匿名内部类。

### Java一般使用传值还是传引用
值传递，就算是对象，拷贝的是对象的地址，如果函数里重新new了一个，不影响原来的。

[参考](https://www.cnblogs.com/fengzheng/p/12419054.html)

### this的用法与应用
[参考](https://blog.csdn.net/jingzi123456789/article/details/71514001)
- 在构造器（构造函数）中初始化成员变量
- 在方法内部表示对“调用方法的那个对象”的引用
- 作为返回值返回对当前对象的引用
- 将this作为当前对象的引用传递给其他方法
- 在构造器中调用构造器，必须将this构造器调用语句放置在构造器（构造函数）体的第一行，否则编译器会出错。

### Java基本类型占用的字节数
![](image/字节数.png)

### Java内存模型
[参考](https://segmentfault.com/a/1190000037799975)
Java 内存模型（Java Memory Model 简称JMM）是一种抽象的概念，并不真实存在，它描述的一组规则或规范，通过这组规范定义了程序中各个变量（包括实例字段、静态字段和构成数组对象的元素）的访问方式。JVM运行程序的实体是线程，而每个线程创建时 JVM 都会为其创建一个工作内存（有些地方称为栈空间），用于存储线程私有的数据，而Java 内存模型中规定所有变量都存储在主内存，其主内存是共享内存区域，所有线程都可以访问，但线程对变量的操作（读取赋值等）必须在工作内存中进行，首先要将变量从主内存拷贝到增加的工作内存空间，然后对变量进行操作，操作完成后再将变量写回主内存，不能直接操作主内存中的变量，工作内存中存储这主内存中的变量副本拷贝，工作内存是每个线程的私有数据区域，因此不同的线程间无法访问对方的工作内存，线程间的通信（传值）必须通过主内存来完成。

### HashCode的默认返回值
[参考](https://segmentfault.com/a/1190000040493992)
hashCode = =0，调用操作系统 OS 的 random() 方法返回随机数。
hashCode == 1，在 STW（stop-the-world）操作中，这种策略通常用于同步方案中。利用对象地址进行计算，使用不经常更新的随机数（GVars.stw_random）参与其中。
hashCode == 2，使用返回 1，用于某些情况下的测试。
hashCode == 3，从 0 开始计算哈希值，不是线程安全的，多个线程可能会得到相同的哈希值。
hashCode == 4，与创建对象的内存位置有关，原样输出。
hashCode == 5，默认值，支持多线程，使用了 Marsaglia 的 xor-shift 算法产生伪随机数。所谓的 xor-shift 算法，简单来说，看起来就是一个移位寄存器，每次移入的位由寄存器中若干位取异或生成。所谓的伪随机数，不是完全随机的，但是真随机生成比较困难，所以只要能通过一定的随机数统计检测，就可以当作真随机数来使用。

### Object有哪些方法
- hashCode
- equals
- clone
- toString
- notify
- notifyAll
- wait
- finalize

### String常用方法
- length
- isEmpty
- charAt
- getChars
- equals
- compareTo
- startsWith
- endsWith
- indexOf
- toLowerCase
- trim
- toCharArray
- format