时间戳 | 数据中心位数5 | 机器标识位数5 | 序列号位数12

初始化数据中心位数和机器标识位数

### 产生下一个ID
synchronized
- 获取当前时间毫秒数 `System.currentTimeMillis()`
- 计算 `lastStmp - currStmp` ，如果时钟回拨不小于5毫秒，则等待相应时间
- 相同毫秒内，序列号自增，当序列号到达最大，自旋等到下一毫秒
- 不同毫秒内，序列号置为0
- id为当前时间戳 + 数据中心id + 机器标识id + 序列号【保证递增】

[美团的leaf方案](https://tech.meituan.com/2017/04/21/mt-leaf.html)
- 使用Zookeeper持久顺序节点的特性自动对snowflake节点配置wokerID
- 缓存workerID文件

[时钟回拨的解决方案](https://blog.csdn.net/qq_26222859/article/details/123689230)

**时间回拨问题**：就是服务器上的时间突然倒退到之前的时间。
- 人为原因，把系统环境的时间改了。
- 有时候不同的机器上需要同步时间，可能不同机器之间存在误差，那么可能会出现时间回拨问题。

解决方案：
- 回拨时间小的时候，不生成 ID，循环等待到时间点到达。
- 上面的方案只适合时钟回拨较小的，如果间隔过大，阻塞等待，肯定是不可取的，因此要么超过一定大小的回拨直接报错，拒绝服务，或者有一种方案是利用拓展位，回拨之后在拓展位上加1就可以了，这样ID依然可以保持唯一。但是这个要求我们提前预留出位数，要么从机器id中，要么从序列号中，腾出一定的位，在时间回拨的时候，这个位置 +1。

### 任务流程
- 新建训练任务
- 生成任务对应的ID
- 上传数据集到指定ID的文件夹
- 通过消息队列执行指定文件夹下的模型训练步骤